#version 330

layout(std140) uniform meshWideBlockPS
{
    int drawDepth;
    float uFarPlane;
    float uNearPlane;
} _10;

uniform sampler2D diffuse;

in vec2 texCoord;
layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 finalColor;
    if (_10.drawDepth == 1)
    {
        float f = _10.uFarPlane;
        float n = _10.uNearPlane;
        float z = (2.0 * n) / ((f + n) - (texture(diffuse, texCoord).x * (f - n)));
        finalColor = vec4(z, z, z, 255.0);
    }
    else
    {
        finalColor = vec4(texture(diffuse, texCoord).xyz, 255.0);
    }
    fragColor = finalColor;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    vec4 uAlphaTestv;
    ivec4 uPixelShaderv;
} _38;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

in vec2 vTexcoord0;
in vec2 vTexcoord1;
in vec2 vTexcoord2;
in vec4 vColor;
layout(location = 0) out vec4 outputColor;

void main()
{
    vec4 tex = texture(uTexture, vTexcoord0);
    vec4 tex2 = texture(uTexture2, vTexcoord1);
    vec4 tex3 = texture(uTexture3, vTexcoord2);
    float uAlphaTest = _38.uAlphaTestv.x;
    if (tex.w < uAlphaTest)
    {
        discard;
    }
    vec4 finalColor = vec4((tex * vColor).xyz, tex.w * vColor.w);
    int uNonOptPixelShader = _38.uPixelShaderv.x;
    if (uNonOptPixelShader == 0)
    {
        vec3 matDiffuse = vColor.xyz * tex.xyz;
        finalColor = vec4(matDiffuse, tex.w * vColor.w);
    }
    else
    {
        if (uNonOptPixelShader == 1)
        {
            vec4 textureMod = tex * tex2;
            float texAlpha = textureMod.w * tex3.w;
            float opacity = texAlpha * vColor.w;
            vec3 matDiffuse_1 = vColor.xyz * textureMod.xyz;
            finalColor = vec4(matDiffuse_1, opacity);
        }
        else
        {
            if (uNonOptPixelShader == 2)
            {
                vec4 textureMod_1 = (tex * tex2) * tex3;
                float texAlpha_1 = textureMod_1.w;
                float opacity_1 = texAlpha_1 * vColor.w;
                vec3 matDiffuse_2 = vColor.xyz * textureMod_1.xyz;
                finalColor = vec4(matDiffuse_2, opacity_1);
            }
            else
            {
                if (uNonOptPixelShader == 3)
                {
                    vec4 textureMod_2 = (tex * tex2) * tex3;
                    float texAlpha_2 = textureMod_2.w;
                    float opacity_2 = texAlpha_2 * vColor.w;
                    vec3 matDiffuse_3 = vColor.xyz * textureMod_2.xyz;
                    finalColor = vec4(matDiffuse_3, opacity_2);
                }
                else
                {
                    if (uNonOptPixelShader == 4)
                    {
                    }
                }
            }
        }
    }
    if (finalColor.w < uAlphaTest)
    {
        discard;
    }
    outputColor = finalColor;
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _30;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _40;

layout(location = 0) in vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4(aPosition, 1.0);
    gl_Position = ((_30.uPMatrix * _30.uLookAtMat) * _40.uPlacementMat) * worldPoint;
}


#version 330

struct LocalLight
{
    vec4 color;
    vec4 position;
    vec4 attenuation;
};

layout(std140) uniform meshWideBlockPS
{
    ivec4 PixelShader_UnFogged_IsAffectedByLight_LightCount;
    vec4 uFogColorAndAlphaTest;
    LocalLight pc_lights[4];
    vec4 uPcColor;
} _29;

layout(std140) uniform modelWideBlockPS
{
    vec4 uViewUp;
    vec4 uSunDirAndFogStart;
    vec4 uSunColorAndFogEnd;
    vec4 uAmbientLight;
} _49;

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _235;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
} _243;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;
uniform sampler2D uTexture4;

in vec3 vNormal;
in vec2 vTexCoord;
in vec2 vTexCoord2;
in vec2 vTexCoord3;
in vec4 vDiffuseColor;
in vec3 vPosition;
layout(location = 0) out vec4 outputColor;

vec3 makeDiffTerm(vec3 matDiffuse, inout vec3 accumLight)
{
    float mult = 1.0;
    vec3 lDiffuse = vec3(0.0);
    vec3 currColor;
    if (_29.PixelShader_UnFogged_IsAffectedByLight_LightCount.z == 1)
    {
        vec3 normalizedN = normalize(vNormal);
        float nDotL = clamp(dot(normalizedN, -_49.uSunDirAndFogStart.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, _49.uViewUp.xyz);
        vec4 AmbientLight = _49.uAmbientLight;
        vec3 adjAmbient = AmbientLight.xyz;
        vec3 adjHorizAmbient = AmbientLight.xyz;
        vec3 adjGroundAmbient = AmbientLight.xyz;
        if (nDotUp >= 0.0)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = _49.uSunColorAndFogEnd.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    else
    {
        currColor = vec3(1.0);
        accumLight = vec3(0.0);
        mult = 1.0;
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * accumLight;
    return sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm);
}

void main()
{
    vec2 texCoord = vTexCoord;
    vec2 texCoord2 = vTexCoord2;
    vec2 texCoord3 = vTexCoord3;
    vec4 tex = texture(uTexture, texCoord);
    vec4 tex2 = texture(uTexture2, texCoord2);
    vec4 tex3 = texture(uTexture3, texCoord3);
    vec4 tex2WithTextCoord1 = texture(uTexture2, texCoord);
    vec4 tex3WithTextCoord1 = texture(uTexture3, texCoord);
    vec4 tex4WithTextCoord2 = texture(uTexture4, texCoord2);
    vec4 finalColor = vec4(0.0);
    vec4 meshResColor = vDiffuseColor;
    vec3 accumLight;
    if (_29.PixelShader_UnFogged_IsAffectedByLight_LightCount.z == 1)
    {
        vec3 vPos3 = vPosition;
        vec3 vNormal3 = normalize(vNormal);
        vec3 lightColor = vec3(0.0);
        int count = int(_29.pc_lights[0].attenuation.w);
        int index = 0;
        LocalLight lightRecord;
        for (;;)
        {
            if (index >= _29.PixelShader_UnFogged_IsAffectedByLight_LightCount.w)
            {
                break;
            }
            lightRecord.color = _29.pc_lights[index].color;
            lightRecord.position = _29.pc_lights[index].position;
            lightRecord.attenuation = _29.pc_lights[index].attenuation;
            vec3 vectorToLight = (_235.uLookAtMat * (_243.uPlacementMat * lightRecord.position)).xyz - vPos3;
            float distanceToLightSqr = dot(vectorToLight, vectorToLight);
            float distanceToLightInv = inversesqrt(distanceToLightSqr);
            float distanceToLight = distanceToLightSqr * distanceToLightInv;
            float diffuseTerm1 = max(dot(vectorToLight, vNormal3) * distanceToLightInv, 0.0);
            vec4 attenuationRec = lightRecord.attenuation;
            float attenuation = 1.0 - clamp((distanceToLight - attenuationRec.x) * (1.0 / (attenuationRec.z - attenuationRec.x)), 0.0, 1.0);
            vec3 attenuatedColor = (lightRecord.color.xyz * attenuation) * attenuationRec.y;
            lightColor += vec3((attenuatedColor * attenuatedColor) * diffuseTerm1);
            index++;
            continue;
        }
        vec3 _315 = clamp(lightColor, vec3(0.0), vec3(1.0));
        meshResColor = vec4(_315.x, _315.y, _315.z, meshResColor.w);
        accumLight = meshResColor.xyz;
    }
    float finalOpacity = 0.0;
    vec3 specular = vec3(0.0);
    vec3 visParams = vec3(1.0);
    vec4 genericParams[3];
    genericParams[0] = vec4(1.0);
    genericParams[1] = vec4(1.0);
    genericParams[2] = vec4(1.0);
    int uPixelShader = _29.PixelShader_UnFogged_IsAffectedByLight_LightCount.x;
    vec3 matDiffuse;
    float opacity;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 1)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 2)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex2.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 3)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = (tex2.w * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 4)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 5)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 6)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = (tex.w * tex2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 7)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = ((tex.w * tex2.w) * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 8)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 9)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 10)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 11)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 13)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = tex2.xyz * tex2.w;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 14)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 15)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    specular = (tex3.xyz * tex3.w) * genericParams[0].z;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 16)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz * tex2.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 17)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + (tex2.w * (((0.300000011920928955078125 * tex2.x) + (0.589999973773956298828125 * tex2.y)) + (0.10999999940395355224609375 * tex2.z)))) * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 18)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex.xyz, tex2.xyz, vec3(tex2.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 19)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 20)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * genericParams[0].y;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 21)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 22)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * tex2.xyz, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 23)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * genericParams[0].y;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 24)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    specular = (tex.xyz * tex.w) * genericParams[0].x;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 25)
    float glowOpacity = clamp(tex3.w * genericParams[0].z, 0.0, 1.0);
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w))) * (1.0 - glowOpacity);
    specular = tex3.xyz * glowOpacity;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 26)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).xyz;
    opacity = mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 27)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 28)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).xyz;
    opacity = (mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).w * tex4WithTextCoord2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 29)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 30)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 31)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 32)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 33)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w * vDiffuseColor.w) * visParams.x;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 34)
    finalColor = vec4(1.0);
    #endif
    #if (FRAGMENTSHADER == 35)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * (((tex * tex2) * tex3) * genericParams[0]).xyz;
    opacity = (((tex * tex2) * tex3) * genericParams[0]).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    vec3 param = matDiffuse;
    vec3 param_1 = accumLight;
    vec3 _1393 = makeDiffTerm(param, param_1);
    finalColor = vec4(_1393 + specular, finalOpacity);
    if (finalColor.w < _29.uFogColorAndAlphaTest.w)
    {
        discard;
    }
    outputColor = finalColor;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    vec3 uColor;
} _13;

layout(location = 0) out vec4 fragColor;
in vec4 vPos;

void main()
{
    fragColor = vec4(_13.uColor, 1.0);
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
} _13;

layout(location = 0) out vec4 outColor;

void main()
{
    vec4 finalColor = _13.uColor;
    outColor = finalColor;
}


#version 330

layout(std140) uniform modelWideBlockPS
{
    vec3 uColor;
} _19;

layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 finalColor = vec4(1.0, 1.0, 0.0, 1.0);
    fragColor = finalColor;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    vec4 uColor;
} _12;

layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 finalColor = _12.uColor;
    fragColor = finalColor;
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _41;

layout(location = 0) in vec3 aPosition;
out vec4 vColor;
layout(location = 1) in vec4 aColor;
out vec2 vTexcoord0;
layout(location = 2) in vec2 aTexcoord0;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    gl_Position = (_41.uPMatrix * _41.uLookAtMat) * aPositionVec4;
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _13;

layout(location = 0) in vec3 aPosition;

void main()
{
    vec4 c_world = inverse(_13.uPMatrix) * vec4(aPosition, 1.0);
    c_world = (c_world * 1.0) / vec4(c_world.w);
    gl_Position = (_13.uPMatrix * _13.uLookAtMat) * vec4(c_world.xyz, 1.0);
}


#version 330
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(location = 0) in vec4 a_position;
out vec2 v_texcoord;

void main()
{
    gl_Position = a_position;
    v_texcoord = (a_position.xy * 0.5) + vec2(0.5);
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _19;

layout(location = 0) in vec2 aPosition;

void main()
{
    gl_Position = (_19.uPMatrix * _19.uLookAtMat) * vec4(aPosition, 0.0, 1.0);
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
} _21;

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _59;

layout(location = 0) in vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4((aPosition.x * _21.uBBScale.x) + _21.uBBCenter.x, (aPosition.y * _21.uBBScale.y) + _21.uBBCenter.y, (aPosition.z * _21.uBBScale.z) + _21.uBBCenter.z, 1.0);
    gl_Position = ((_59.uPMatrix * _59.uLookAtMat) * _21.uPlacementMat) * worldPoint;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    int waterType;
} _9;

uniform sampler2D uTexture;

layout(location = 0) out vec4 outputColor;
in vec3 vPosition;

void main()
{
    if (_9.waterType == 13)
    {
        outputColor = vec4(0.0, 0.0, 0.300000011920928955078125, 0.5);
    }
    else
    {
        if (_9.waterType == 14)
        {
            outputColor = vec4(0.0, 0.0, 0.800000011920928955078125, 0.800000011920928955078125);
        }
        else
        {
            if (_9.waterType == 19)
            {
                outputColor = vec4(0.300000011920928955078125, 0.0, 0.0, 0.5);
            }
            else
            {
                if (_9.waterType == 20)
                {
                    outputColor = vec4(0.0, 0.5, 0.0, 0.5);
                }
                else
                {
                    outputColor = vec4(0.5);
                }
            }
        }
    }
}


#version 330

layout(std140) uniform modelWideBlockPS
{
    vec4 uViewUp;
    vec4 uSunDir_FogStart;
    vec4 uSunColor_uFogEnd;
    vec4 uAmbientLight;
    vec4 FogColor;
    int uNewFormula;
} _33;

uniform sampler2D uDiffuseTexture;
uniform sampler2D uNormalTexture;

in vec2 vChunkCoords;
in vec3 vPosition;
layout(location = 0) out vec4 fragColor;

vec3 makeDiffTerm(vec3 matDiffuse, vec3 vNormal)
{
    float mult = 1.0;
    vec3 lDiffuse = vec3(0.0);
    vec3 currColor;
    if (true)
    {
        vec3 normalizedN = normalize(vNormal);
        float nDotL = dot(normalizedN, -_33.uSunDir_FogStart.xyz);
        float nDotUp = dot(normalizedN, _33.uViewUp.xyz);
        vec4 AmbientLight = _33.uAmbientLight;
        vec3 adjAmbient = AmbientLight.xyz;
        vec3 adjHorizAmbient = AmbientLight.xyz;
        vec3 adjGroundAmbient = AmbientLight.xyz;
        if (nDotUp >= 0.0)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = _33.uSunColor_uFogEnd.xyz * clamp(nDotL, 0.0, 1.0);
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    else
    {
        currColor = vec3(1.0);
        mult = 1.0;
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = vec3(0.0);
    return sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm);
}

void main()
{
    vec2 TextureCoords = vec2(vChunkCoords.x, vChunkCoords.y);
    vec4 texDiffuse = texture(uDiffuseTexture, TextureCoords);
    vec3 matDiffuse = texDiffuse.xyz;
    vec3 vNormal = (texture(uNormalTexture, TextureCoords).xyz * 2.0) - vec3(1.0);
    vNormal = vec3(-vNormal.z, -vNormal.x, vNormal.y);
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    vec4 finalColor = vec4(makeDiffTerm(param, param_1), 1.0);
    float specBlend = texDiffuse.w;
    vec3 halfVec = -normalize(_33.uSunDir_FogStart.xyz + normalize(vPosition));
    vec3 lSpecular = _33.uSunColor_uFogEnd.xyz * pow(max(0.0, dot(halfVec, vNormal)), 20.0);
    vec3 specTerm = vec3(specBlend) * lSpecular;
    vec3 _208 = finalColor.xyz + specTerm;
    finalColor = vec4(_208.x, _208.y, _208.z, finalColor.w);
    vec3 fogColor = _33.FogColor.xyz;
    float fog_start = _33.uSunDir_FogStart.w;
    float fog_end = _33.uSunColor_uFogEnd.w;
    float fog_rate = 1.5;
    float fog_bias = 0.00999999977648258209228515625;
    float distanceToCamera = length(vPosition);
    float z_depth = distanceToCamera - fog_bias;
    float expFog = 1.0 / exp(max(0.0, z_depth - fog_start) * fog_rate);
    float heightFog = 1.0;
    expFog += heightFog;
    float endFadeFog = clamp((fog_end - distanceToCamera) / (0.699999988079071044921875 * fog_end), 0.0, 1.0);
    vec3 _262 = mix(fogColor, finalColor.xyz, vec3(min(expFog, endFadeFog)));
    finalColor = vec4(_262.x, _262.y, _262.z, finalColor.w);
    finalColor.w = 1.0;
    fragColor = finalColor;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    float gauss_offsets[5];
    float gauss_weights[5];
    vec2 uResolution;
} _34;

uniform sampler2D u_sampler;
uniform sampler2D u_depth;

in vec2 v_texcoord;
layout(location = 0) out vec4 outputColor;

void main()
{
    float FXAA_SPAN_MAX = 8.0;
    float FXAA_REDUCE_MUL = 0.125;
    float FXAA_REDUCE_MIN = 0.0078125;
    vec3 rgbNW = texture(u_sampler, v_texcoord + (vec2(-1.0) / _34.uResolution)).xyz;
    vec3 rgbNE = texture(u_sampler, v_texcoord + (vec2(1.0, -1.0) / _34.uResolution)).xyz;
    vec3 rgbSW = texture(u_sampler, v_texcoord + (vec2(-1.0, 1.0) / _34.uResolution)).xyz;
    vec3 rgbSE = texture(u_sampler, v_texcoord + (vec2(1.0) / _34.uResolution)).xyz;
    vec3 rgbM = texture(u_sampler, v_texcoord).xyz;
    vec3 luma = vec3(0.2989999949932098388671875, 0.58700001239776611328125, 0.114000000059604644775390625);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM = dot(rgbM, luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y = (lumaNW + lumaSW) - (lumaNE + lumaSE);
    float dirReduce = max((((lumaNW + lumaNE) + lumaSW) + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) / _34.uResolution;
    vec3 rgbA = (texture(u_sampler, v_texcoord + (dir * (-0.16666667163372039794921875))).xyz + texture(u_sampler, v_texcoord + (dir * 0.16666667163372039794921875)).xyz) * 0.5;
    vec3 rgbB = (rgbA * 0.5) + ((texture(u_sampler, v_texcoord + (dir * (-0.5))).xyz + texture(u_sampler, v_texcoord + (dir * 0.5)).xyz) * 0.25);
    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
    {
        outputColor = vec4(rgbA.x, rgbA.y, rgbA.z, outputColor.w);
    }
    else
    {
        outputColor = vec4(rgbB.x, rgbB.y, rgbB.z, outputColor.w);
    }
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _53;

layout(std140) uniform meshWideBlockVS
{
    vec4 uPos;
} _100;

layout(location = 4) in float aIndex;
layout(location = 0) in vec3 aHeight;
out vec2 vChunkCoords;
out vec3 vPosition;
out vec4 vColor;
layout(location = 1) in vec4 aColor;
out vec3 vVertexLighting;
layout(location = 2) in vec4 aVertexLighting;
out vec3 vNormal;
layout(location = 3) in vec3 aNormal;

void main()
{
    float iX = mod(aIndex, 17.0);
    float iY = floor(aIndex / 17.0);
    if (iX > 8.0100002288818359375)
    {
        iY += 0.5;
        iX -= 8.5;
    }
    vec4 worldPoint = vec4(aHeight, 1.0);
    vChunkCoords = vec2(iX, iY);
    vPosition = (_53.uLookAtMat * worldPoint).xyz;
    vColor = aColor;
    vVertexLighting = aVertexLighting.xyz;
    vNormal = (_53.uLookAtMat * vec4(aNormal, 0.0)).xyz;
    gl_Position = (_53.uPMatrix * _53.uLookAtMat) * worldPoint;
}


#version 330

layout(std140) uniform modelWideBlockPS
{
    vec4 uViewUp;
    vec4 uSunDir_FogStart;
    vec4 uSunColor_uFogEnd;
    vec4 uAmbientLight;
    vec4 FogColor;
} _33;

layout(std140) uniform meshWideBlockPS
{
    vec4 uHeightScale;
    vec4 uHeightOffset;
} _184;

uniform sampler2D uAlphaTexture;
uniform sampler2D uLayerHeight0;
uniform sampler2D uLayerHeight1;
uniform sampler2D uLayerHeight2;
uniform sampler2D uLayerHeight3;
uniform sampler2D uLayer0;
uniform sampler2D uLayer1;
uniform sampler2D uLayer2;
uniform sampler2D uLayer3;

in vec3 vNormal;
in vec3 vVertexLighting;
in vec2 vChunkCoords;
in vec4 vColor;
in vec3 vPosition;
layout(location = 0) out vec4 outColor;

vec3 makeDiffTerm(vec3 matDiffuse)
{
    float mult = 1.0;
    vec3 lDiffuse = vec3(0.0);
    vec3 currColor;
    if (true)
    {
        vec3 normalizedN = normalize(vNormal);
        float nDotL = dot(normalizedN, -_33.uSunDir_FogStart.xyz);
        float nDotUp = dot(normalizedN, _33.uViewUp.xyz);
        vec4 AmbientLight = _33.uAmbientLight;
        vec3 adjAmbient = AmbientLight.xyz;
        vec3 adjHorizAmbient = AmbientLight.xyz;
        vec3 adjGroundAmbient = AmbientLight.xyz;
        if (nDotUp >= 0.0)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = _33.uSunColor_uFogEnd.xyz * clamp(nDotL, 0.0, 1.0);
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    else
    {
        currColor = vec3(1.0);
        mult = 1.0;
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * vVertexLighting;
    return sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm);
}

void main()
{
    vec2 vTexCoord = vChunkCoords;
    vec2 alphaCoord = vec2(vChunkCoords.x / 8.0, vChunkCoords.y / 8.0);
    vec3 alphaBlend = texture(uAlphaTexture, alphaCoord).yzw;
    vec2 tcLayer0 = vTexCoord;
    vec2 tcLayer1 = vTexCoord;
    vec2 tcLayer2 = vTexCoord;
    vec2 tcLayer3 = vTexCoord;
    float minusAlphaBlendSum = 1.0 - clamp(dot(alphaBlend, vec3(1.0)), 0.0, 1.0);
    vec4 weightsVector = vec4(minusAlphaBlendSum, alphaBlend);
    float weightedTexture_x = minusAlphaBlendSum * ((texture(uLayerHeight0, tcLayer0).w * _184.uHeightScale.x) + _184.uHeightOffset.x);
    float weightedTexture_y = weightsVector.y * ((texture(uLayerHeight1, tcLayer1).w * _184.uHeightScale.y) + _184.uHeightOffset.y);
    float weightedTexture_z = weightsVector.z * ((texture(uLayerHeight2, tcLayer2).w * _184.uHeightScale.z) + _184.uHeightOffset.z);
    float weightedTexture_w = weightsVector.w * ((texture(uLayerHeight3, tcLayer3).w * _184.uHeightScale.w) + _184.uHeightOffset.w);
    vec4 weights = vec4(weightedTexture_x, weightedTexture_y, weightedTexture_z, weightedTexture_w);
    vec4 weights_temp = weights * (vec4(1.0) - clamp(vec4(max(max(weightedTexture_x, weightedTexture_y), max(weightedTexture_z, weightedTexture_w))) - weights, vec4(0.0), vec4(1.0)));
    vec4 weightsNormalized = weights_temp / vec4(dot(vec4(1.0), weights_temp));
    vec4 weightedLayer_0 = texture(uLayer0, tcLayer0) * weightsNormalized.x;
    vec3 matDiffuse_0 = weightedLayer_0.xyz;
    float specBlend_0 = weightedLayer_0.w;
    vec4 weightedLayer_1 = texture(uLayer1, tcLayer1) * weightsNormalized.y;
    vec3 matDiffuse_1 = matDiffuse_0 + weightedLayer_1.xyz;
    float specBlend_1 = specBlend_0 + weightedLayer_1.w;
    vec4 weightedLayer_2 = texture(uLayer2, tcLayer1) * weightsNormalized.z;
    vec3 matDiffuse_2 = matDiffuse_1 + weightedLayer_2.xyz;
    float specBlend_2 = specBlend_1 + weightedLayer_2.w;
    vec4 weightedLayer_3 = texture(uLayer3, tcLayer1) * weightsNormalized.w;
    vec3 matDiffuse_3 = matDiffuse_2 + weightedLayer_3.xyz;
    float specBlend_3 = specBlend_2 + weightedLayer_3.w;
    vec4 final = vec4(matDiffuse_3, specBlend_3);
    vec3 matDiffuse = final.xyz * vColor.xyz;
    vec3 param = matDiffuse;
    vec4 finalColor = vec4(makeDiffTerm(param), 1.0);
    float specBlend = final.w;
    vec3 halfVec = -normalize(_33.uSunDir_FogStart.xyz + normalize(vPosition));
    vec3 lSpecular = _33.uSunColor_uFogEnd.xyz * pow(max(0.0, dot(halfVec, vNormal)), 20.0);
    vec3 specTerm = vec3(specBlend) * lSpecular;
    vec3 _392 = finalColor.xyz + specTerm;
    finalColor = vec4(_392.x, _392.y, _392.z, finalColor.w);
    finalColor.w = 1.0;
    outColor = finalColor;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    vec3 uColor;
} _22;

layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 finalColor = vec4(1.0);
    finalColor.w = 1.0;
    fragColor = finalColor;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
} _133;

layout(std140) uniform meshWideBlockVS
{
    ivec4 vertexShader_IsAffectedByLight;
    vec4 color_Transparency;
    mat4 uTextMat[2];
} _230;

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _237;

layout(location = 0) in vec3 aPosition;
layout(location = 3) in vec4 boneWeights;
layout(location = 2) in vec4 bones;
layout(location = 1) in vec3 aNormal;
out vec2 vTexCoord2;
out vec2 vTexCoord3;
out vec4 vDiffuseColor;
out vec2 vTexCoord;
layout(location = 4) in vec2 aTexCoord;
layout(location = 5) in vec2 aTexCoord2;
out vec3 vNormal;
out vec3 vPosition;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

float edgeScan(vec3 position, vec3 normal)
{
    float dotProductClamped = clamp(dot(-normalize(position), normal), 0.0, 1.0);
    return clamp(((2.7000000476837158203125 * dotProductClamped) * dotProductClamped) - 0.4000000059604644775390625, 0.0, 1.0);
}

void main()
{
    vec4 modelPoint = vec4(0.0);
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 boneTransformMat = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0));
    mat4 _143 = _133.uBoneMatrixes[bones.x] * boneWeights.x;
    boneTransformMat = mat4(boneTransformMat[0] + _143[0], boneTransformMat[1] + _143[1], boneTransformMat[2] + _143[2], boneTransformMat[3] + _143[3]);
    mat4 _164 = _133.uBoneMatrixes[bones.y] * boneWeights.y;
    boneTransformMat = mat4(boneTransformMat[0] + _164[0], boneTransformMat[1] + _164[1], boneTransformMat[2] + _164[2], boneTransformMat[3] + _164[3]);
    mat4 _185 = _133.uBoneMatrixes[bones.z] * boneWeights.z;
    boneTransformMat = mat4(boneTransformMat[0] + _185[0], boneTransformMat[1] + _185[1], boneTransformMat[2] + _185[2], boneTransformMat[3] + _185[3]);
    mat4 _207 = _133.uBoneMatrixes[bones.w] * boneWeights.w;
    boneTransformMat = mat4(boneTransformMat[0] + _207[0], boneTransformMat[1] + _207[1], boneTransformMat[2] + _207[2], boneTransformMat[3] + _207[3]);
    mat4 placementMat = _133.uPlacementMat;
    vec4 lDiffuseColor = _230.color_Transparency;
    mat4 cameraMatrix = (_237.uLookAtMat * placementMat) * boneTransformMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    mat4 param = _237.uLookAtMat;
    mat4 param_1 = placementMat;
    mat4 param_2 = boneTransformMat;
    mat3 viewModelMatTransposed = (blizzTranspose(param) * blizzTranspose(param_1)) * blizzTranspose(param_2);
    vec3 normal = normalize(viewModelMatTransposed * aNormal);
    vec4 combinedColor = clamp(lDiffuseColor, vec4(0.0), vec4(1.0));
    vec4 combinedColorHalved = combinedColor * 0.5;
    vec3 param_3 = cameraPoint.xyz;
    vec3 param_4 = normal;
    vec2 envCoord = posToTexCoord(param_3, param_4);
    vec3 param_5 = cameraPoint.xyz;
    vec3 param_6 = normal;
    float edgeScanVal = edgeScan(param_5, param_6);
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vec2(0.0);
    int uVertexShader = _230.vertexShader_IsAffectedByLight.x;
    #if (VERTEXSHADER == 0)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 1)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    #endif
    #if (VERTEXSHADER == 2)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 3)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    #endif
    #if (VERTEXSHADER == 4)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 5)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = envCoord;
    #endif
    #if (VERTEXSHADER == 6)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 7)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 8)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 9)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 10)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 11)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 12)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 13)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = envCoord;
    #endif
    #if (VERTEXSHADER == 14)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 15)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = vTexCoord3;
    #endif
    #if (VERTEXSHADER == 16)
    vec4 in_col0 = vec4(1.0);
    vDiffuseColor = vec4((in_col0.xyz * 0.5).x, (in_col0.xyz * 0.5).y, (in_col0.xyz * 0.5).z, in_col0.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vTexCoord3;
    #endif
    #if (VERTEXSHADER == 17)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 18)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    gl_Position = _237.uPMatrix * cameraPoint;
    vNormal = normal;
    vPosition = cameraPoint.xyz;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _58;

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _75;

layout(std140) uniform meshWideBlockVS
{
    ivec4 VertexShader_UseLitColor;
} _164;

layout(location = 0) in vec3 aPosition;
out vec4 vPosition;
layout(location = 5) in vec4 aColor;
out vec3 vNormal;
layout(location = 1) in vec3 aNormal;
out vec4 vColor;
out vec4 vColor2;
layout(location = 6) in vec4 aColor2;
out vec2 vTexCoord;
layout(location = 2) in vec2 aTexCoord;
out vec2 vTexCoord2;
layout(location = 3) in vec2 aTexCoord2;
out vec2 vTexCoord3;
layout(location = 4) in vec2 aTexCoord3;

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

void main()
{
    vec4 worldPoint = _58.uPlacementMat * vec4(aPosition, 1.0);
    vec4 cameraPoint = _75.uLookAtMat * worldPoint;
    mat4 viewModelMat = _75.uLookAtMat * _58.uPlacementMat;
    mat3 viewModelMatTransposed = mat3(vec3(viewModelMat[0].xyz), vec3(viewModelMat[1].xyz), vec3(viewModelMat[2].xyz));
    gl_Position = _75.uPMatrix * cameraPoint;
    vPosition = vec4(cameraPoint.xyz, aColor.w);
    vNormal = normalize(viewModelMatTransposed * aNormal);
    vColor = vec4(0.5, 0.499989986419677734375, 0.5, 1.0);
    vColor2 = vec4(aColor.zyx * 2.0, aColor2.w);
    int uVertexShader = _164.VertexShader_UseLitColor.x;
    #if (VERTEXSHADER == (-1))
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 0)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 1)
    vTexCoord = aTexCoord;
    vTexCoord2 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 2)
    vTexCoord = aTexCoord;
    vec3 param = vPosition.xyz;
    vec3 param_1 = vNormal;
    vTexCoord2 = posToTexCoord(param, param_1);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 3)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 4)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 5)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    #endif
    #if (VERTEXSHADER == 6)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 7)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 8)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _19;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _29;

layout(location = 0) in vec3 aPosition;
out vec4 vPos;

void main()
{
    gl_Position = ((_19.uPMatrix * _19.uLookAtMat) * _29.uPlacementMat) * vec4(aPosition, 1.0);
    gl_PointSize = 10.0;
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _47;

layout(location = 0) in vec3 aPosition;
out vec4 vColor;
layout(location = 1) in vec4 aColor;
out vec2 vTexcoord0;
layout(location = 2) in vec2 aTexcoord0;
out vec2 vTexcoord1;
layout(location = 3) in vec2 aTexcoord1;
out vec2 vTexcoord2;
layout(location = 4) in vec2 aTexcoord2;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vTexcoord1 = aTexcoord1;
    vTexcoord2 = aTexcoord2;
    gl_Position = (_47.uPMatrix * _47.uLookAtMat) * aPositionVec4;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    vec3 uPos;
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _55;

layout(location = 1) in float aIndex;
layout(location = 0) in float aHeight;
out vec2 vChunkCoords;
out vec3 vPosition;

void main()
{
    float stepX = floor(aIndex / 16641.0);
    float division = 129.0;
    if (stepX > 0.100000001490116119384765625)
    {
        division = 128.0;
    }
    float offset = (stepX * 129.0) * 129.0;
    float iX = mod(aIndex - offset, division) + (stepX * 0.5);
    float iY = floor((aIndex - offset) / division) + (stepX * 0.5);
    vec4 worldPoint = vec4(_55.uPos.x - (iY * 4.166666507720947265625), _55.uPos.y - (iX * 4.166666507720947265625), aHeight, 1.0);
    vChunkCoords = vec2(iX / 128.0, iY / 128.0);
    vPosition = (_55.uLookAtMat * worldPoint).xyz;
    gl_Position = (_55.uPMatrix * _55.uLookAtMat) * worldPoint;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    vec4 uViewUp;
    vec4 uSunDir_FogStart;
    vec4 uSunColor_uFogEnd;
    vec4 uAmbientLight;
    vec4 uAmbientLight2AndIsBatchA;
    ivec4 UseLitColor_EnableAlpha_PixelShader;
    vec4 FogColor_AlphaTest;
} _21;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _895;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

in vec3 vNormal;
in vec4 vColor2;
in vec4 vPosition;
in vec2 vTexCoord;
in vec2 vTexCoord2;
in vec2 vTexCoord3;
in vec4 vColor;
layout(location = 0) out vec4 outputColor;

vec3 makeDiffTerm(vec3 matDiffuse)
{
    vec3 lDiffuse = vec3(0.0);
    vec3 currColor;
    if (_21.UseLitColor_EnableAlpha_PixelShader.x == 1)
    {
        vec3 normalizedN = normalize(vNormal);
        float nDotL = dot(normalizedN, -_21.uSunDir_FogStart.xyz);
        float nDotUp = dot(normalizedN, _21.uViewUp.xyz);
        vec3 precomputed = vColor2.xyz;
        vec3 ambientColor = _21.uAmbientLight.xyz;
        if (_21.uAmbientLight2AndIsBatchA.w > 0.0)
        {
            ambientColor = mix(_21.uAmbientLight.xyz, _21.uAmbientLight2AndIsBatchA.xyz, vec3(vPosition.w));
        }
        vec3 adjAmbient = ambientColor + precomputed;
        vec3 adjHorizAmbient = ambientColor + precomputed;
        vec3 adjGroundAmbient = ambientColor + precomputed;
        if (nDotUp >= 0.0)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
        lDiffuse = _21.uSunColor_uFogEnd.xyz * clamp(nDotL, 0.0, 1.0);
    }
    else
    {
        currColor = vec3(1.0) * _21.uAmbientLight.xyz;
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * vec3(0.0);
    return sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm);
}

void main()
{
    vec4 tex = texture(uTexture, vTexCoord);
    vec4 tex2 = texture(uTexture2, vTexCoord2);
    vec4 tex3 = texture(uTexture3, vTexCoord3);
    if (_21.UseLitColor_EnableAlpha_PixelShader.y == 1)
    {
        if ((tex.w - 0.501960813999176025390625) < 0.0)
        {
            discard;
        }
    }
    int uPixelShader = _21.UseLitColor_EnableAlpha_PixelShader.z;
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    #if (FRAGMENTSHADER == (-1))
    vec3 param = (tex.xyz * vColor.xyz) + (tex2.xyz * vColor2.zyx);
    finalColor = vec4(makeDiffTerm(param), tex.w);
    #endif
    #if (FRAGMENTSHADER == 0)
    vec3 matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_1 = matDiffuse;
    finalColor = vec4(makeDiffTerm(param_1), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 1)
    vec3 matDiffuse_1 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_2 = matDiffuse_1;
    finalColor = vec4(makeDiffTerm(param_2), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 2)
    vec3 matDiffuse_2 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_3 = matDiffuse_2;
    finalColor = vec4(makeDiffTerm(param_3), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 3)
    vec3 matDiffuse_3 = tex.xyz * (vColor.xyz * 2.0);
    vec3 env = tex2.xyz * tex.w;
    vec3 param_4 = matDiffuse_3;
    finalColor = vec4(makeDiffTerm(param_4) + env, vColor.w);
    #endif
    #if (FRAGMENTSHADER == 4)
    vec3 matDiffuse_4 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_5 = matDiffuse_4;
    finalColor = vec4(makeDiffTerm(param_5), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 5)
    vec3 matDiffuse_5 = tex.xyz * (vColor.xyz * 2.0);
    vec3 env_1 = (tex.xyz * tex.w) * tex2.xyz;
    vec3 param_6 = matDiffuse_5;
    finalColor = vec4(makeDiffTerm(param_6) + env_1, vColor.w);
    #endif
    #if (FRAGMENTSHADER == 6)
    vec3 layer1 = tex.xyz;
    vec3 layer2 = mix(layer1, tex2.xyz, vec3(tex2.w));
    vec3 matDiffuse_6 = (vColor.xyz * 2.0) * mix(layer2, layer1, vec3(vColor2.w));
    vec3 param_7 = matDiffuse_6;
    finalColor = vec4(makeDiffTerm(param_7), 1.0);
    #endif
    #if (FRAGMENTSHADER == 7)
    vec4 colorMix = mix(tex2, tex, vec4(vColor2.w));
    vec3 env_2 = (colorMix.xyz * colorMix.w) * tex3.xyz;
    vec3 matDiffuse_7 = colorMix.xyz * (vColor.xyz * 2.0);
    vec3 param_8 = matDiffuse_7;
    finalColor = vec4(makeDiffTerm(param_8) + env_2, vColor.w);
    #endif
    #if (FRAGMENTSHADER == 8)
    vec3 layer1_1 = tex.xyz;
    vec3 layer2_1 = tex2.xyz;
    vec3 matDiffuse_8 = (vColor.xyz * 2.0) * mix(layer2_1, layer1_1, vec3(vColor2.w));
    vec3 param_9 = matDiffuse_8;
    finalColor = vec4(makeDiffTerm(param_9), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 9)
    vec3 matDiffuse_9 = tex.xyz * (vColor.xyz * 2.0);
    vec3 env_3 = (tex2.xyz * tex2.w) * vColor2.w;
    vec3 param_10 = matDiffuse_9;
    finalColor = vec4(makeDiffTerm(param_10) + env_3, vColor.w);
    #endif
    #if (FRAGMENTSHADER == 10)
    float mixFactor = clamp(tex3.w * vColor2.w, 0.0, 1.0);
    vec3 matDiffuse_10 = (vColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(mixFactor)), tex.xyz, vec3(tex.w));
    vec3 param_11 = matDiffuse_10;
    finalColor = vec4(makeDiffTerm(param_11), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 11)
    vec3 matDiffuse_11 = tex.xyz * (vColor.xyz * 2.0);
    vec3 env_4 = ((tex.xyz * tex.w) * tex2.xyz) + ((tex3.xyz * tex3.w) * vColor2.w);
    vec3 param_12 = matDiffuse_11;
    finalColor = vec4(makeDiffTerm(param_12) + env_4, vColor.w);
    #endif
    #if (FRAGMENTSHADER == 12)
    vec3 matDiffuse_12 = (vColor.xyz * 2.0) * mix(tex2.xyz, tex.xyz, vec3(vColor2.w));
    vec3 param_13 = matDiffuse_12;
    finalColor = vec4(makeDiffTerm(param_13), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 13)
    vec3 t1diffuse = tex2.xyz * (1.0 - tex2.w);
    vec3 matDiffuse_13 = (vColor.xyz * 2.0) * mix(t1diffuse, tex.xyz, vec3(vColor2.w));
    vec3 env_5 = (tex2.xyz * tex2.w) * (1.0 - vColor2.w);
    vec3 param_14 = matDiffuse_13;
    finalColor = vec4(makeDiffTerm(param_14) + env_5, vColor.w);
    #endif
    #if (FRAGMENTSHADER == 13)
    vec3 matDiffuse_14 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_15 = matDiffuse_14;
    finalColor = vec4(makeDiffTerm(param_15), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 14)
    vec3 matDiffuse_15 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_16 = matDiffuse_15;
    finalColor = vec4(makeDiffTerm(param_16), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 15)
    vec3 matDiffuse_16 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_17 = matDiffuse_16;
    finalColor = vec4(makeDiffTerm(param_17), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 16)
    vec3 matDiffuse_17 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_18 = matDiffuse_17;
    finalColor = vec4(makeDiffTerm(param_18), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 17)
    vec3 matDiffuse_18 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_19 = matDiffuse_18;
    finalColor = vec4(makeDiffTerm(param_19), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 18)
    vec3 matDiffuse_19 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_20 = matDiffuse_19;
    finalColor = vec4(makeDiffTerm(param_20), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 19)
    vec3 matDiffuse_20 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_21 = matDiffuse_20;
    finalColor = vec4(makeDiffTerm(param_21), vColor.w);
    #endif
    if (finalColor.w < _21.FogColor_AlphaTest.w)
    {
        discard;
    }
    vec3 fogColor = _21.FogColor_AlphaTest.xyz;
    float fog_start = _21.uSunDir_FogStart.w;
    float fog_end = _21.uSunColor_uFogEnd.w;
    float fog_rate = 1.5;
    float fog_bias = 0.00999999977648258209228515625;
    float distanceToCamera = length(vPosition.xyz);
    float z_depth = distanceToCamera - fog_bias;
    float expFog = 1.0 / exp(max(0.0, z_depth - fog_start) * fog_rate);
    float heightFog = 1.0;
    expFog += heightFog;
    float endFadeFog = clamp((fog_end - distanceToCamera) / (0.699999988079071044921875 * fog_end), 0.0, 1.0);
    vec3 _885 = mix(fogColor, finalColor.xyz, vec3(min(expFog, endFadeFog)));
    finalColor = vec4(_885.x, _885.y, _885.z, finalColor.w);
    finalColor.w = 1.0;
    outputColor = finalColor;
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _24;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _32;

layout(location = 0) in vec3 aPosition;
out vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 cameraMatrix = _24.uLookAtMat * _32.uPlacementMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    gl_Position = _24.uPMatrix * cameraPoint;
    vPosition = cameraPoint.xyz;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    float uWidth;
    float uHeight;
    float uX;
    float uY;
} _36;

out vec2 texCoord;
layout(location = 0) in vec2 position;
layout(location = 1) in vec2 _texture;

void main()
{
    texCoord = (position * 0.5) + vec2(0.5);
    gl_Position = vec4((((((position.x + 1.0) / 2.0) * _36.uWidth) + _36.uX) * 2.0) - 1.0, (((((position.y + 1.0) / 2.0) * _36.uHeight) + _36.uY) * 2.0) - 1.0, 0.0, 1.0);
}


#version 330
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(binding = 5) uniform sampler2D uTexture;

in vec2 vTexcoord0;
layout(location = 0) out vec4 outputColor;
in vec4 vColor;

void main()
{
    vec4 tex = texture(uTexture, vTexcoord0);
    outputColor = vec4(vColor.xyz * tex.xyz, tex.w * vColor.w);
}


#version 100

struct meshWideBlockPS
{
    int drawDepth;
    float uFarPlane;
    float uNearPlane;
};

uniform meshWideBlockPS _10;

uniform sampler2D diffuse;

varying vec2 texCoord;

void main()
{
    vec4 finalColor;
    if (_10.drawDepth == 1)
    {
        float f = _10.uFarPlane;
        float n = _10.uNearPlane;
        float z = (2.0 * n) / ((f + n) - (texture2D(diffuse, texCoord).x * (f - n)));
        finalColor = vec4(z, z, z, 255.0);
    }
    else
    {
        finalColor = vec4(texture2D(diffuse, texCoord).xyz, 255.0);
    }
    gl_FragData[0] = finalColor;
}


#version 100

struct meshWideBlockPS
{
    vec4 uAlphaTestv;
    ivec4 uPixelShaderv;
};

uniform meshWideBlockPS _38;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

varying vec2 vTexcoord0;
varying vec2 vTexcoord1;
varying vec2 vTexcoord2;
varying vec4 vColor;

void main()
{
    vec4 tex = texture2D(uTexture, vTexcoord0);
    vec4 tex2 = texture2D(uTexture2, vTexcoord1);
    vec4 tex3 = texture2D(uTexture3, vTexcoord2);
    float uAlphaTest = _38.uAlphaTestv.x;
    if (tex.w < uAlphaTest)
    {
        discard;
    }
    vec4 finalColor = vec4((tex * vColor).xyz, tex.w * vColor.w);
    int uNonOptPixelShader = _38.uPixelShaderv.x;
    if (uNonOptPixelShader == 0)
    {
        vec3 matDiffuse = vColor.xyz * tex.xyz;
        finalColor = vec4(matDiffuse, tex.w * vColor.w);
    }
    else
    {
        if (uNonOptPixelShader == 1)
        {
            vec4 textureMod = tex * tex2;
            float texAlpha = textureMod.w * tex3.w;
            float opacity = texAlpha * vColor.w;
            vec3 matDiffuse_1 = vColor.xyz * textureMod.xyz;
            finalColor = vec4(matDiffuse_1, opacity);
        }
        else
        {
            if (uNonOptPixelShader == 2)
            {
                vec4 textureMod_1 = (tex * tex2) * tex3;
                float texAlpha_1 = textureMod_1.w;
                float opacity_1 = texAlpha_1 * vColor.w;
                vec3 matDiffuse_2 = vColor.xyz * textureMod_1.xyz;
                finalColor = vec4(matDiffuse_2, opacity_1);
            }
            else
            {
                if (uNonOptPixelShader == 3)
                {
                    vec4 textureMod_2 = (tex * tex2) * tex3;
                    float texAlpha_2 = textureMod_2.w;
                    float opacity_2 = texAlpha_2 * vColor.w;
                    vec3 matDiffuse_3 = vColor.xyz * textureMod_2.xyz;
                    finalColor = vec4(matDiffuse_3, opacity_2);
                }
                else
                {
                    if (uNonOptPixelShader == 4)
                    {
                    }
                }
            }
        }
    }
    if (finalColor.w < uAlphaTest)
    {
        discard;
    }
    gl_FragData[0] = finalColor;
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _30;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _40;

attribute vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4(aPosition, 1.0);
    gl_Position = ((_30.uPMatrix * _30.uLookAtMat) * _40.uPlacementMat) * worldPoint;
}


#version 100

struct LocalLight
{
    vec4 color;
    vec4 position;
    vec4 attenuation;
};

struct meshWideBlockPS
{
    ivec4 PixelShader_UnFogged_IsAffectedByLight_LightCount;
    vec4 uFogColorAndAlphaTest;
    LocalLight pc_lights[4];
    vec4 uPcColor;
};

uniform meshWideBlockPS _29;

struct modelWideBlockPS
{
    vec4 uViewUp;
    vec4 uSunDirAndFogStart;
    vec4 uSunColorAndFogEnd;
    vec4 uAmbientLight;
};

uniform modelWideBlockPS _49;

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _235;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
};

uniform modelWideBlockVS _243;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;
uniform sampler2D uTexture4;

varying vec3 vNormal;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vDiffuseColor;
varying vec3 vPosition;

vec3 makeDiffTerm(vec3 matDiffuse, inout vec3 accumLight)
{
    float mult = 1.0;
    vec3 lDiffuse = vec3(0.0);
    vec3 currColor;
    if (_29.PixelShader_UnFogged_IsAffectedByLight_LightCount.z == 1)
    {
        vec3 normalizedN = normalize(vNormal);
        float nDotL = clamp(dot(normalizedN, -_49.uSunDirAndFogStart.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, _49.uViewUp.xyz);
        vec4 AmbientLight = _49.uAmbientLight;
        vec3 adjAmbient = AmbientLight.xyz;
        vec3 adjHorizAmbient = AmbientLight.xyz;
        vec3 adjGroundAmbient = AmbientLight.xyz;
        if (nDotUp >= 0.0)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = _49.uSunColorAndFogEnd.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    else
    {
        currColor = vec3(1.0);
        accumLight = vec3(0.0);
        mult = 1.0;
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * accumLight;
    return sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm);
}

void main()
{
    vec2 texCoord = vTexCoord;
    vec2 texCoord2 = vTexCoord2;
    vec2 texCoord3 = vTexCoord3;
    vec4 tex = texture2D(uTexture, texCoord);
    vec4 tex2 = texture2D(uTexture2, texCoord2);
    vec4 tex3 = texture2D(uTexture3, texCoord3);
    vec4 tex2WithTextCoord1 = texture2D(uTexture2, texCoord);
    vec4 tex3WithTextCoord1 = texture2D(uTexture3, texCoord);
    vec4 tex4WithTextCoord2 = texture2D(uTexture4, texCoord2);
    vec4 finalColor = vec4(0.0);
    vec4 meshResColor = vDiffuseColor;
    vec3 accumLight;
    if (_29.PixelShader_UnFogged_IsAffectedByLight_LightCount.z == 1)
    {
        vec3 vPos3 = vPosition;
        vec3 vNormal3 = normalize(vNormal);
        vec3 lightColor = vec3(0.0);
        int count = int(_29.pc_lights[0].attenuation.w);
        int index = 0;
        LocalLight lightRecord;
        for (;;)
        {
            if (index >= _29.PixelShader_UnFogged_IsAffectedByLight_LightCount.w)
            {
                break;
            }
            lightRecord.color = _29.pc_lights[index].color;
            lightRecord.position = _29.pc_lights[index].position;
            lightRecord.attenuation = _29.pc_lights[index].attenuation;
            vec3 vectorToLight = (_235.uLookAtMat * (_243.uPlacementMat * lightRecord.position)).xyz - vPos3;
            float distanceToLightSqr = dot(vectorToLight, vectorToLight);
            float distanceToLightInv = inversesqrt(distanceToLightSqr);
            float distanceToLight = distanceToLightSqr * distanceToLightInv;
            float diffuseTerm1 = max(dot(vectorToLight, vNormal3) * distanceToLightInv, 0.0);
            vec4 attenuationRec = lightRecord.attenuation;
            float attenuation = 1.0 - clamp((distanceToLight - attenuationRec.x) * (1.0 / (attenuationRec.z - attenuationRec.x)), 0.0, 1.0);
            vec3 attenuatedColor = (lightRecord.color.xyz * attenuation) * attenuationRec.y;
            lightColor += vec3((attenuatedColor * attenuatedColor) * diffuseTerm1);
            index++;
            continue;
        }
        vec3 _315 = clamp(lightColor, vec3(0.0), vec3(1.0));
        meshResColor = vec4(_315.x, _315.y, _315.z, meshResColor.w);
        accumLight = meshResColor.xyz;
    }
    float finalOpacity = 0.0;
    vec3 specular = vec3(0.0);
    vec3 visParams = vec3(1.0);
    vec4 genericParams[3];
    genericParams[0] = vec4(1.0);
    genericParams[1] = vec4(1.0);
    genericParams[2] = vec4(1.0);
    int uPixelShader = _29.PixelShader_UnFogged_IsAffectedByLight_LightCount.x;
    vec3 matDiffuse;
    float opacity;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 1)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 2)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex2.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 3)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = (tex2.w * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 4)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 5)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 6)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = (tex.w * tex2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 7)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = ((tex.w * tex2.w) * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 8)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 9)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 10)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 11)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 13)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = tex2.xyz * tex2.w;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 14)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 15)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    specular = (tex3.xyz * tex3.w) * genericParams[0].z;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 16)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz * tex2.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 17)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + (tex2.w * (((0.300000011920928955078125 * tex2.x) + (0.589999973773956298828125 * tex2.y)) + (0.10999999940395355224609375 * tex2.z)))) * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 18)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex.xyz, tex2.xyz, vec3(tex2.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 19)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 20)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * genericParams[0].y;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 21)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 22)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * tex2.xyz, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 23)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * genericParams[0].y;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 24)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    specular = (tex.xyz * tex.w) * genericParams[0].x;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 25)
    float glowOpacity = clamp(tex3.w * genericParams[0].z, 0.0, 1.0);
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w))) * (1.0 - glowOpacity);
    specular = tex3.xyz * glowOpacity;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 26)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).xyz;
    opacity = mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 27)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 28)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).xyz;
    opacity = (mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).w * tex4WithTextCoord2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 29)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 30)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 31)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 32)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 33)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w * vDiffuseColor.w) * visParams.x;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 34)
    finalColor = vec4(1.0);
    #endif
    #if (FRAGMENTSHADER == 35)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * (((tex * tex2) * tex3) * genericParams[0]).xyz;
    opacity = (((tex * tex2) * tex3) * genericParams[0]).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    vec3 param = matDiffuse;
    vec3 param_1 = accumLight;
    vec3 _1393 = makeDiffTerm(param, param_1);
    finalColor = vec4(_1393 + specular, finalOpacity);
    if (finalColor.w < _29.uFogColorAndAlphaTest.w)
    {
        discard;
    }
    gl_FragData[0] = finalColor;
}


#version 100

struct modelWideBlockVS
{
    vec3 uColor;
};

uniform modelWideBlockVS _13;

varying vec4 vPos;

void main()
{
    gl_FragData[0] = vec4(_13.uColor, 1.0);
}


#version 100

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
};

uniform modelWideBlockVS _13;

void main()
{
    vec4 finalColor = _13.uColor;
    gl_FragData[0] = finalColor;
}


#version 100

struct modelWideBlockPS
{
    vec3 uColor;
};

uniform modelWideBlockPS _19;

void main()
{
    vec4 finalColor = vec4(1.0, 1.0, 0.0, 1.0);
    gl_FragData[0] = finalColor;
}


#version 100

struct modelWideBlockVS
{
    vec4 uColor;
};

uniform modelWideBlockVS _12;

void main()
{
    vec4 finalColor = _12.uColor;
    gl_FragData[0] = finalColor;
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _41;

attribute vec3 aPosition;
varying vec4 vColor;
attribute vec4 aColor;
varying vec2 vTexcoord0;
attribute vec2 aTexcoord0;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    gl_Position = (_41.uPMatrix * _41.uLookAtMat) * aPositionVec4;
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _13;

attribute vec3 aPosition;

void main()
{
    vec4 c_world = inverse(_13.uPMatrix) * vec4(aPosition, 1.0);
    c_world = (c_world * 1.0) / vec4(c_world.w);
    gl_Position = (_13.uPMatrix * _13.uLookAtMat) * vec4(c_world.xyz, 1.0);
}


#version 100
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

attribute vec4 a_position;
varying vec2 v_texcoord;

void main()
{
    gl_Position = a_position;
    v_texcoord = (a_position.xy * 0.5) + vec2(0.5);
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _19;

attribute vec2 aPosition;

void main()
{
    gl_Position = (_19.uPMatrix * _19.uLookAtMat) * vec4(aPosition, 0.0, 1.0);
}


#version 100

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
};

uniform modelWideBlockVS _21;

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _59;

attribute vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4((aPosition.x * _21.uBBScale.x) + _21.uBBCenter.x, (aPosition.y * _21.uBBScale.y) + _21.uBBCenter.y, (aPosition.z * _21.uBBScale.z) + _21.uBBCenter.z, 1.0);
    gl_Position = ((_59.uPMatrix * _59.uLookAtMat) * _21.uPlacementMat) * worldPoint;
}


#version 100

struct meshWideBlockPS
{
    int waterType;
};

uniform meshWideBlockPS _9;

uniform sampler2D uTexture;

varying vec3 vPosition;

void main()
{
    if (_9.waterType == 13)
    {
        gl_FragData[0] = vec4(0.0, 0.0, 0.300000011920928955078125, 0.5);
    }
    else
    {
        if (_9.waterType == 14)
        {
            gl_FragData[0] = vec4(0.0, 0.0, 0.800000011920928955078125, 0.800000011920928955078125);
        }
        else
        {
            if (_9.waterType == 19)
            {
                gl_FragData[0] = vec4(0.300000011920928955078125, 0.0, 0.0, 0.5);
            }
            else
            {
                if (_9.waterType == 20)
                {
                    gl_FragData[0] = vec4(0.0, 0.5, 0.0, 0.5);
                }
                else
                {
                    gl_FragData[0] = vec4(0.5);
                }
            }
        }
    }
}


#version 100

struct modelWideBlockPS
{
    vec4 uViewUp;
    vec4 uSunDir_FogStart;
    vec4 uSunColor_uFogEnd;
    vec4 uAmbientLight;
    vec4 FogColor;
    int uNewFormula;
};

uniform modelWideBlockPS _33;

uniform sampler2D uDiffuseTexture;
uniform sampler2D uNormalTexture;

varying vec2 vChunkCoords;
varying vec3 vPosition;

vec3 makeDiffTerm(vec3 matDiffuse, vec3 vNormal)
{
    float mult = 1.0;
    vec3 lDiffuse = vec3(0.0);
    vec3 currColor;
    if (true)
    {
        vec3 normalizedN = normalize(vNormal);
        float nDotL = dot(normalizedN, -_33.uSunDir_FogStart.xyz);
        float nDotUp = dot(normalizedN, _33.uViewUp.xyz);
        vec4 AmbientLight = _33.uAmbientLight;
        vec3 adjAmbient = AmbientLight.xyz;
        vec3 adjHorizAmbient = AmbientLight.xyz;
        vec3 adjGroundAmbient = AmbientLight.xyz;
        if (nDotUp >= 0.0)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = _33.uSunColor_uFogEnd.xyz * clamp(nDotL, 0.0, 1.0);
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    else
    {
        currColor = vec3(1.0);
        mult = 1.0;
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = vec3(0.0);
    return sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm);
}

void main()
{
    vec2 TextureCoords = vec2(vChunkCoords.x, vChunkCoords.y);
    vec4 texDiffuse = texture2D(uDiffuseTexture, TextureCoords);
    vec3 matDiffuse = texDiffuse.xyz;
    vec3 vNormal = (texture2D(uNormalTexture, TextureCoords).xyz * 2.0) - vec3(1.0);
    vNormal = vec3(-vNormal.z, -vNormal.x, vNormal.y);
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    vec4 finalColor = vec4(makeDiffTerm(param, param_1), 1.0);
    float specBlend = texDiffuse.w;
    vec3 halfVec = -normalize(_33.uSunDir_FogStart.xyz + normalize(vPosition));
    vec3 lSpecular = _33.uSunColor_uFogEnd.xyz * pow(max(0.0, dot(halfVec, vNormal)), 20.0);
    vec3 specTerm = vec3(specBlend) * lSpecular;
    vec3 _208 = finalColor.xyz + specTerm;
    finalColor = vec4(_208.x, _208.y, _208.z, finalColor.w);
    vec3 fogColor = _33.FogColor.xyz;
    float fog_start = _33.uSunDir_FogStart.w;
    float fog_end = _33.uSunColor_uFogEnd.w;
    float fog_rate = 1.5;
    float fog_bias = 0.00999999977648258209228515625;
    float distanceToCamera = length(vPosition);
    float z_depth = distanceToCamera - fog_bias;
    float expFog = 1.0 / exp(max(0.0, z_depth - fog_start) * fog_rate);
    float heightFog = 1.0;
    expFog += heightFog;
    float endFadeFog = clamp((fog_end - distanceToCamera) / (0.699999988079071044921875 * fog_end), 0.0, 1.0);
    vec3 _262 = mix(fogColor, finalColor.xyz, vec3(min(expFog, endFadeFog)));
    finalColor = vec4(_262.x, _262.y, _262.z, finalColor.w);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct meshWideBlockPS
{
    float gauss_offsets[5];
    float gauss_weights[5];
    vec2 uResolution;
};

uniform meshWideBlockPS _34;

uniform sampler2D u_sampler;
uniform sampler2D u_depth;

varying vec2 v_texcoord;

void main()
{
    float FXAA_SPAN_MAX = 8.0;
    float FXAA_REDUCE_MUL = 0.125;
    float FXAA_REDUCE_MIN = 0.0078125;
    vec3 rgbNW = texture2D(u_sampler, v_texcoord + (vec2(-1.0) / _34.uResolution)).xyz;
    vec3 rgbNE = texture2D(u_sampler, v_texcoord + (vec2(1.0, -1.0) / _34.uResolution)).xyz;
    vec3 rgbSW = texture2D(u_sampler, v_texcoord + (vec2(-1.0, 1.0) / _34.uResolution)).xyz;
    vec3 rgbSE = texture2D(u_sampler, v_texcoord + (vec2(1.0) / _34.uResolution)).xyz;
    vec3 rgbM = texture2D(u_sampler, v_texcoord).xyz;
    vec3 luma = vec3(0.2989999949932098388671875, 0.58700001239776611328125, 0.114000000059604644775390625);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM = dot(rgbM, luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y = (lumaNW + lumaSW) - (lumaNE + lumaSE);
    float dirReduce = max((((lumaNW + lumaNE) + lumaSW) + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) / _34.uResolution;
    vec3 rgbA = (texture2D(u_sampler, v_texcoord + (dir * (-0.16666667163372039794921875))).xyz + texture2D(u_sampler, v_texcoord + (dir * 0.16666667163372039794921875)).xyz) * 0.5;
    vec3 rgbB = (rgbA * 0.5) + ((texture2D(u_sampler, v_texcoord + (dir * (-0.5))).xyz + texture2D(u_sampler, v_texcoord + (dir * 0.5)).xyz) * 0.25);
    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
    {
        gl_FragData[0] = vec4(rgbA.x, rgbA.y, rgbA.z, gl_FragData[0].w);
    }
    else
    {
        gl_FragData[0] = vec4(rgbB.x, rgbB.y, rgbB.z, gl_FragData[0].w);
    }
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _53;

struct meshWideBlockVS
{
    vec4 uPos;
};

uniform meshWideBlockVS _100;

attribute float aIndex;
attribute vec3 aHeight;
varying vec2 vChunkCoords;
varying vec3 vPosition;
varying vec4 vColor;
attribute vec4 aColor;
varying vec3 vVertexLighting;
attribute vec4 aVertexLighting;
varying vec3 vNormal;
attribute vec3 aNormal;

void main()
{
    float iX = mod(aIndex, 17.0);
    float iY = floor(aIndex / 17.0);
    if (iX > 8.0100002288818359375)
    {
        iY += 0.5;
        iX -= 8.5;
    }
    vec4 worldPoint = vec4(aHeight, 1.0);
    vChunkCoords = vec2(iX, iY);
    vPosition = (_53.uLookAtMat * worldPoint).xyz;
    vColor = aColor;
    vVertexLighting = aVertexLighting.xyz;
    vNormal = (_53.uLookAtMat * vec4(aNormal, 0.0)).xyz;
    gl_Position = (_53.uPMatrix * _53.uLookAtMat) * worldPoint;
}


#version 100

struct modelWideBlockPS
{
    vec4 uViewUp;
    vec4 uSunDir_FogStart;
    vec4 uSunColor_uFogEnd;
    vec4 uAmbientLight;
    vec4 FogColor;
};

uniform modelWideBlockPS _33;

struct meshWideBlockPS
{
    vec4 uHeightScale;
    vec4 uHeightOffset;
};

uniform meshWideBlockPS _184;

uniform sampler2D uAlphaTexture;
uniform sampler2D uLayerHeight0;
uniform sampler2D uLayerHeight1;
uniform sampler2D uLayerHeight2;
uniform sampler2D uLayerHeight3;
uniform sampler2D uLayer0;
uniform sampler2D uLayer1;
uniform sampler2D uLayer2;
uniform sampler2D uLayer3;

varying vec3 vNormal;
varying vec3 vVertexLighting;
varying vec2 vChunkCoords;
varying vec4 vColor;
varying vec3 vPosition;

vec3 makeDiffTerm(vec3 matDiffuse)
{
    float mult = 1.0;
    vec3 lDiffuse = vec3(0.0);
    vec3 currColor;
    if (true)
    {
        vec3 normalizedN = normalize(vNormal);
        float nDotL = dot(normalizedN, -_33.uSunDir_FogStart.xyz);
        float nDotUp = dot(normalizedN, _33.uViewUp.xyz);
        vec4 AmbientLight = _33.uAmbientLight;
        vec3 adjAmbient = AmbientLight.xyz;
        vec3 adjHorizAmbient = AmbientLight.xyz;
        vec3 adjGroundAmbient = AmbientLight.xyz;
        if (nDotUp >= 0.0)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = _33.uSunColor_uFogEnd.xyz * clamp(nDotL, 0.0, 1.0);
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    else
    {
        currColor = vec3(1.0);
        mult = 1.0;
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * vVertexLighting;
    return sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm);
}

void main()
{
    vec2 vTexCoord = vChunkCoords;
    vec2 alphaCoord = vec2(vChunkCoords.x / 8.0, vChunkCoords.y / 8.0);
    vec3 alphaBlend = texture2D(uAlphaTexture, alphaCoord).yzw;
    vec2 tcLayer0 = vTexCoord;
    vec2 tcLayer1 = vTexCoord;
    vec2 tcLayer2 = vTexCoord;
    vec2 tcLayer3 = vTexCoord;
    float minusAlphaBlendSum = 1.0 - clamp(dot(alphaBlend, vec3(1.0)), 0.0, 1.0);
    vec4 weightsVector = vec4(minusAlphaBlendSum, alphaBlend);
    float weightedTexture_x = minusAlphaBlendSum * ((texture2D(uLayerHeight0, tcLayer0).w * _184.uHeightScale.x) + _184.uHeightOffset.x);
    float weightedTexture_y = weightsVector.y * ((texture2D(uLayerHeight1, tcLayer1).w * _184.uHeightScale.y) + _184.uHeightOffset.y);
    float weightedTexture_z = weightsVector.z * ((texture2D(uLayerHeight2, tcLayer2).w * _184.uHeightScale.z) + _184.uHeightOffset.z);
    float weightedTexture_w = weightsVector.w * ((texture2D(uLayerHeight3, tcLayer3).w * _184.uHeightScale.w) + _184.uHeightOffset.w);
    vec4 weights = vec4(weightedTexture_x, weightedTexture_y, weightedTexture_z, weightedTexture_w);
    vec4 weights_temp = weights * (vec4(1.0) - clamp(vec4(max(max(weightedTexture_x, weightedTexture_y), max(weightedTexture_z, weightedTexture_w))) - weights, vec4(0.0), vec4(1.0)));
    vec4 weightsNormalized = weights_temp / vec4(dot(vec4(1.0), weights_temp));
    vec4 weightedLayer_0 = texture2D(uLayer0, tcLayer0) * weightsNormalized.x;
    vec3 matDiffuse_0 = weightedLayer_0.xyz;
    float specBlend_0 = weightedLayer_0.w;
    vec4 weightedLayer_1 = texture2D(uLayer1, tcLayer1) * weightsNormalized.y;
    vec3 matDiffuse_1 = matDiffuse_0 + weightedLayer_1.xyz;
    float specBlend_1 = specBlend_0 + weightedLayer_1.w;
    vec4 weightedLayer_2 = texture2D(uLayer2, tcLayer1) * weightsNormalized.z;
    vec3 matDiffuse_2 = matDiffuse_1 + weightedLayer_2.xyz;
    float specBlend_2 = specBlend_1 + weightedLayer_2.w;
    vec4 weightedLayer_3 = texture2D(uLayer3, tcLayer1) * weightsNormalized.w;
    vec3 matDiffuse_3 = matDiffuse_2 + weightedLayer_3.xyz;
    float specBlend_3 = specBlend_2 + weightedLayer_3.w;
    vec4 final = vec4(matDiffuse_3, specBlend_3);
    vec3 matDiffuse = final.xyz * vColor.xyz;
    vec3 param = matDiffuse;
    vec4 finalColor = vec4(makeDiffTerm(param), 1.0);
    float specBlend = final.w;
    vec3 halfVec = -normalize(_33.uSunDir_FogStart.xyz + normalize(vPosition));
    vec3 lSpecular = _33.uSunColor_uFogEnd.xyz * pow(max(0.0, dot(halfVec, vNormal)), 20.0);
    vec3 specTerm = vec3(specBlend) * lSpecular;
    vec3 _392 = finalColor.xyz + specTerm;
    finalColor = vec4(_392.x, _392.y, _392.z, finalColor.w);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct meshWideBlockPS
{
    vec3 uColor;
};

uniform meshWideBlockPS _22;

void main()
{
    vec4 finalColor = vec4(1.0);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
};

uniform modelWideBlockVS _133;

struct meshWideBlockVS
{
    ivec4 vertexShader_IsAffectedByLight;
    vec4 color_Transparency;
    mat4 uTextMat[2];
};

uniform meshWideBlockVS _230;

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _237;

attribute vec3 aPosition;
attribute vec4 boneWeights;
attribute vec4 bones;
attribute vec3 aNormal;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vDiffuseColor;
varying vec2 vTexCoord;
attribute vec2 aTexCoord;
attribute vec2 aTexCoord2;
varying vec3 vNormal;
varying vec3 vPosition;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

float edgeScan(vec3 position, vec3 normal)
{
    float dotProductClamped = clamp(dot(-normalize(position), normal), 0.0, 1.0);
    return clamp(((2.7000000476837158203125 * dotProductClamped) * dotProductClamped) - 0.4000000059604644775390625, 0.0, 1.0);
}

void main()
{
    vec4 modelPoint = vec4(0.0);
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 boneTransformMat = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0));
    mat4 _143 = _133.uBoneMatrixes[bones.x] * boneWeights.x;
    boneTransformMat = mat4(boneTransformMat[0] + _143[0], boneTransformMat[1] + _143[1], boneTransformMat[2] + _143[2], boneTransformMat[3] + _143[3]);
    mat4 _164 = _133.uBoneMatrixes[bones.y] * boneWeights.y;
    boneTransformMat = mat4(boneTransformMat[0] + _164[0], boneTransformMat[1] + _164[1], boneTransformMat[2] + _164[2], boneTransformMat[3] + _164[3]);
    mat4 _185 = _133.uBoneMatrixes[bones.z] * boneWeights.z;
    boneTransformMat = mat4(boneTransformMat[0] + _185[0], boneTransformMat[1] + _185[1], boneTransformMat[2] + _185[2], boneTransformMat[3] + _185[3]);
    mat4 _207 = _133.uBoneMatrixes[bones.w] * boneWeights.w;
    boneTransformMat = mat4(boneTransformMat[0] + _207[0], boneTransformMat[1] + _207[1], boneTransformMat[2] + _207[2], boneTransformMat[3] + _207[3]);
    mat4 placementMat = _133.uPlacementMat;
    vec4 lDiffuseColor = _230.color_Transparency;
    mat4 cameraMatrix = (_237.uLookAtMat * placementMat) * boneTransformMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    mat4 param = _237.uLookAtMat;
    mat4 param_1 = placementMat;
    mat4 param_2 = boneTransformMat;
    mat3 viewModelMatTransposed = (blizzTranspose(param) * blizzTranspose(param_1)) * blizzTranspose(param_2);
    vec3 normal = normalize(viewModelMatTransposed * aNormal);
    vec4 combinedColor = clamp(lDiffuseColor, vec4(0.0), vec4(1.0));
    vec4 combinedColorHalved = combinedColor * 0.5;
    vec3 param_3 = cameraPoint.xyz;
    vec3 param_4 = normal;
    vec2 envCoord = posToTexCoord(param_3, param_4);
    vec3 param_5 = cameraPoint.xyz;
    vec3 param_6 = normal;
    float edgeScanVal = edgeScan(param_5, param_6);
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vec2(0.0);
    int uVertexShader = _230.vertexShader_IsAffectedByLight.x;
    #if (VERTEXSHADER == 0)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 1)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    #endif
    #if (VERTEXSHADER == 2)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 3)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    #endif
    #if (VERTEXSHADER == 4)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 5)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = envCoord;
    #endif
    #if (VERTEXSHADER == 6)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 7)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 8)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 9)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 10)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 11)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 12)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 13)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = envCoord;
    #endif
    #if (VERTEXSHADER == 14)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 15)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = vTexCoord3;
    #endif
    #if (VERTEXSHADER == 16)
    vec4 in_col0 = vec4(1.0);
    vDiffuseColor = vec4((in_col0.xyz * 0.5).x, (in_col0.xyz * 0.5).y, (in_col0.xyz * 0.5).z, in_col0.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vTexCoord3;
    #endif
    #if (VERTEXSHADER == 17)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 18)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    gl_Position = _237.uPMatrix * cameraPoint;
    vNormal = normal;
    vPosition = cameraPoint.xyz;
}


#version 100

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _58;

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _75;

struct meshWideBlockVS
{
    ivec4 VertexShader_UseLitColor;
};

uniform meshWideBlockVS _164;

attribute vec3 aPosition;
varying vec4 vPosition;
attribute vec4 aColor;
varying vec3 vNormal;
attribute vec3 aNormal;
varying vec4 vColor;
varying vec4 vColor2;
attribute vec4 aColor2;
varying vec2 vTexCoord;
attribute vec2 aTexCoord;
varying vec2 vTexCoord2;
attribute vec2 aTexCoord2;
varying vec2 vTexCoord3;
attribute vec2 aTexCoord3;

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

void main()
{
    vec4 worldPoint = _58.uPlacementMat * vec4(aPosition, 1.0);
    vec4 cameraPoint = _75.uLookAtMat * worldPoint;
    mat4 viewModelMat = _75.uLookAtMat * _58.uPlacementMat;
    mat3 viewModelMatTransposed = mat3(vec3(viewModelMat[0].xyz), vec3(viewModelMat[1].xyz), vec3(viewModelMat[2].xyz));
    gl_Position = _75.uPMatrix * cameraPoint;
    vPosition = vec4(cameraPoint.xyz, aColor.w);
    vNormal = normalize(viewModelMatTransposed * aNormal);
    vColor = vec4(0.5, 0.499989986419677734375, 0.5, 1.0);
    vColor2 = vec4(aColor.zyx * 2.0, aColor2.w);
    int uVertexShader = _164.VertexShader_UseLitColor.x;
    #if (VERTEXSHADER == (-1))
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 0)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 1)
    vTexCoord = aTexCoord;
    vTexCoord2 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 2)
    vTexCoord = aTexCoord;
    vec3 param = vPosition.xyz;
    vec3 param_1 = vNormal;
    vTexCoord2 = posToTexCoord(param, param_1);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 3)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 4)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 5)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    #endif
    #if (VERTEXSHADER == 6)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 7)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 8)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _19;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _29;

attribute vec3 aPosition;
varying vec4 vPos;

void main()
{
    gl_Position = ((_19.uPMatrix * _19.uLookAtMat) * _29.uPlacementMat) * vec4(aPosition, 1.0);
    gl_PointSize = 10.0;
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _47;

attribute vec3 aPosition;
varying vec4 vColor;
attribute vec4 aColor;
varying vec2 vTexcoord0;
attribute vec2 aTexcoord0;
varying vec2 vTexcoord1;
attribute vec2 aTexcoord1;
varying vec2 vTexcoord2;
attribute vec2 aTexcoord2;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vTexcoord1 = aTexcoord1;
    vTexcoord2 = aTexcoord2;
    gl_Position = (_47.uPMatrix * _47.uLookAtMat) * aPositionVec4;
}


#version 100

struct modelWideBlockVS
{
    vec3 uPos;
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform modelWideBlockVS _55;

attribute float aIndex;
attribute float aHeight;
varying vec2 vChunkCoords;
varying vec3 vPosition;

void main()
{
    float stepX = floor(aIndex / 16641.0);
    float division = 129.0;
    if (stepX > 0.100000001490116119384765625)
    {
        division = 128.0;
    }
    float offset = (stepX * 129.0) * 129.0;
    float iX = mod(aIndex - offset, division) + (stepX * 0.5);
    float iY = floor((aIndex - offset) / division) + (stepX * 0.5);
    vec4 worldPoint = vec4(_55.uPos.x - (iY * 4.166666507720947265625), _55.uPos.y - (iX * 4.166666507720947265625), aHeight, 1.0);
    vChunkCoords = vec2(iX / 128.0, iY / 128.0);
    vPosition = (_55.uLookAtMat * worldPoint).xyz;
    gl_Position = (_55.uPMatrix * _55.uLookAtMat) * worldPoint;
}


#version 100

struct meshWideBlockPS
{
    vec4 uViewUp;
    vec4 uSunDir_FogStart;
    vec4 uSunColor_uFogEnd;
    vec4 uAmbientLight;
    vec4 uAmbientLight2AndIsBatchA;
    ivec4 UseLitColor_EnableAlpha_PixelShader;
    vec4 FogColor_AlphaTest;
};

uniform meshWideBlockPS _21;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _895;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

varying vec3 vNormal;
varying vec4 vColor2;
varying vec4 vPosition;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vColor;

vec3 makeDiffTerm(vec3 matDiffuse)
{
    vec3 lDiffuse = vec3(0.0);
    vec3 currColor;
    if (_21.UseLitColor_EnableAlpha_PixelShader.x == 1)
    {
        vec3 normalizedN = normalize(vNormal);
        float nDotL = dot(normalizedN, -_21.uSunDir_FogStart.xyz);
        float nDotUp = dot(normalizedN, _21.uViewUp.xyz);
        vec3 precomputed = vColor2.xyz;
        vec3 ambientColor = _21.uAmbientLight.xyz;
        if (_21.uAmbientLight2AndIsBatchA.w > 0.0)
        {
            ambientColor = mix(_21.uAmbientLight.xyz, _21.uAmbientLight2AndIsBatchA.xyz, vec3(vPosition.w));
        }
        vec3 adjAmbient = ambientColor + precomputed;
        vec3 adjHorizAmbient = ambientColor + precomputed;
        vec3 adjGroundAmbient = ambientColor + precomputed;
        if (nDotUp >= 0.0)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
        lDiffuse = _21.uSunColor_uFogEnd.xyz * clamp(nDotL, 0.0, 1.0);
    }
    else
    {
        currColor = vec3(1.0) * _21.uAmbientLight.xyz;
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * vec3(0.0);
    return sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm);
}

void main()
{
    vec4 tex = texture2D(uTexture, vTexCoord);
    vec4 tex2 = texture2D(uTexture2, vTexCoord2);
    vec4 tex3 = texture2D(uTexture3, vTexCoord3);
    if (_21.UseLitColor_EnableAlpha_PixelShader.y == 1)
    {
        if ((tex.w - 0.501960813999176025390625) < 0.0)
        {
            discard;
        }
    }
    int uPixelShader = _21.UseLitColor_EnableAlpha_PixelShader.z;
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    #if (FRAGMENTSHADER == (-1))
    vec3 param = (tex.xyz * vColor.xyz) + (tex2.xyz * vColor2.zyx);
    finalColor = vec4(makeDiffTerm(param), tex.w);
    #endif
    #if (FRAGMENTSHADER == 0)
    vec3 matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_1 = matDiffuse;
    finalColor = vec4(makeDiffTerm(param_1), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 1)
    vec3 matDiffuse_1 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_2 = matDiffuse_1;
    finalColor = vec4(makeDiffTerm(param_2), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 2)
    vec3 matDiffuse_2 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_3 = matDiffuse_2;
    finalColor = vec4(makeDiffTerm(param_3), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 3)
    vec3 matDiffuse_3 = tex.xyz * (vColor.xyz * 2.0);
    vec3 env = tex2.xyz * tex.w;
    vec3 param_4 = matDiffuse_3;
    finalColor = vec4(makeDiffTerm(param_4) + env, vColor.w);
    #endif
    #if (FRAGMENTSHADER == 4)
    vec3 matDiffuse_4 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_5 = matDiffuse_4;
    finalColor = vec4(makeDiffTerm(param_5), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 5)
    vec3 matDiffuse_5 = tex.xyz * (vColor.xyz * 2.0);
    vec3 env_1 = (tex.xyz * tex.w) * tex2.xyz;
    vec3 param_6 = matDiffuse_5;
    finalColor = vec4(makeDiffTerm(param_6) + env_1, vColor.w);
    #endif
    #if (FRAGMENTSHADER == 6)
    vec3 layer1 = tex.xyz;
    vec3 layer2 = mix(layer1, tex2.xyz, vec3(tex2.w));
    vec3 matDiffuse_6 = (vColor.xyz * 2.0) * mix(layer2, layer1, vec3(vColor2.w));
    vec3 param_7 = matDiffuse_6;
    finalColor = vec4(makeDiffTerm(param_7), 1.0);
    #endif
    #if (FRAGMENTSHADER == 7)
    vec4 colorMix = mix(tex2, tex, vec4(vColor2.w));
    vec3 env_2 = (colorMix.xyz * colorMix.w) * tex3.xyz;
    vec3 matDiffuse_7 = colorMix.xyz * (vColor.xyz * 2.0);
    vec3 param_8 = matDiffuse_7;
    finalColor = vec4(makeDiffTerm(param_8) + env_2, vColor.w);
    #endif
    #if (FRAGMENTSHADER == 8)
    vec3 layer1_1 = tex.xyz;
    vec3 layer2_1 = tex2.xyz;
    vec3 matDiffuse_8 = (vColor.xyz * 2.0) * mix(layer2_1, layer1_1, vec3(vColor2.w));
    vec3 param_9 = matDiffuse_8;
    finalColor = vec4(makeDiffTerm(param_9), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 9)
    vec3 matDiffuse_9 = tex.xyz * (vColor.xyz * 2.0);
    vec3 env_3 = (tex2.xyz * tex2.w) * vColor2.w;
    vec3 param_10 = matDiffuse_9;
    finalColor = vec4(makeDiffTerm(param_10) + env_3, vColor.w);
    #endif
    #if (FRAGMENTSHADER == 10)
    float mixFactor = clamp(tex3.w * vColor2.w, 0.0, 1.0);
    vec3 matDiffuse_10 = (vColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(mixFactor)), tex.xyz, vec3(tex.w));
    vec3 param_11 = matDiffuse_10;
    finalColor = vec4(makeDiffTerm(param_11), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 11)
    vec3 matDiffuse_11 = tex.xyz * (vColor.xyz * 2.0);
    vec3 env_4 = ((tex.xyz * tex.w) * tex2.xyz) + ((tex3.xyz * tex3.w) * vColor2.w);
    vec3 param_12 = matDiffuse_11;
    finalColor = vec4(makeDiffTerm(param_12) + env_4, vColor.w);
    #endif
    #if (FRAGMENTSHADER == 12)
    vec3 matDiffuse_12 = (vColor.xyz * 2.0) * mix(tex2.xyz, tex.xyz, vec3(vColor2.w));
    vec3 param_13 = matDiffuse_12;
    finalColor = vec4(makeDiffTerm(param_13), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 13)
    vec3 t1diffuse = tex2.xyz * (1.0 - tex2.w);
    vec3 matDiffuse_13 = (vColor.xyz * 2.0) * mix(t1diffuse, tex.xyz, vec3(vColor2.w));
    vec3 env_5 = (tex2.xyz * tex2.w) * (1.0 - vColor2.w);
    vec3 param_14 = matDiffuse_13;
    finalColor = vec4(makeDiffTerm(param_14) + env_5, vColor.w);
    #endif
    #if (FRAGMENTSHADER == 13)
    vec3 matDiffuse_14 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_15 = matDiffuse_14;
    finalColor = vec4(makeDiffTerm(param_15), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 14)
    vec3 matDiffuse_15 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_16 = matDiffuse_15;
    finalColor = vec4(makeDiffTerm(param_16), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 15)
    vec3 matDiffuse_16 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_17 = matDiffuse_16;
    finalColor = vec4(makeDiffTerm(param_17), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 16)
    vec3 matDiffuse_17 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_18 = matDiffuse_17;
    finalColor = vec4(makeDiffTerm(param_18), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 17)
    vec3 matDiffuse_18 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_19 = matDiffuse_18;
    finalColor = vec4(makeDiffTerm(param_19), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 18)
    vec3 matDiffuse_19 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_20 = matDiffuse_19;
    finalColor = vec4(makeDiffTerm(param_20), vColor.w);
    #endif
    #if (FRAGMENTSHADER == 19)
    vec3 matDiffuse_20 = tex.xyz * (vColor.xyz * 2.0);
    vec3 param_21 = matDiffuse_20;
    finalColor = vec4(makeDiffTerm(param_21), vColor.w);
    #endif
    if (finalColor.w < _21.FogColor_AlphaTest.w)
    {
        discard;
    }
    vec3 fogColor = _21.FogColor_AlphaTest.xyz;
    float fog_start = _21.uSunDir_FogStart.w;
    float fog_end = _21.uSunColor_uFogEnd.w;
    float fog_rate = 1.5;
    float fog_bias = 0.00999999977648258209228515625;
    float distanceToCamera = length(vPosition.xyz);
    float z_depth = distanceToCamera - fog_bias;
    float expFog = 1.0 / exp(max(0.0, z_depth - fog_start) * fog_rate);
    float heightFog = 1.0;
    expFog += heightFog;
    float endFadeFog = clamp((fog_end - distanceToCamera) / (0.699999988079071044921875 * fog_end), 0.0, 1.0);
    vec3 _885 = mix(fogColor, finalColor.xyz, vec3(min(expFog, endFadeFog)));
    finalColor = vec4(_885.x, _885.y, _885.z, finalColor.w);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _24;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _32;

attribute vec3 aPosition;
varying vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 cameraMatrix = _24.uLookAtMat * _32.uPlacementMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    gl_Position = _24.uPMatrix * cameraPoint;
    vPosition = cameraPoint.xyz;
}


#version 100

struct meshWideBlockPS
{
    float uWidth;
    float uHeight;
    float uX;
    float uY;
};

uniform meshWideBlockPS _36;

varying vec2 texCoord;
attribute vec2 position;
attribute vec2 _texture;

void main()
{
    texCoord = (position * 0.5) + vec2(0.5);
    gl_Position = vec4((((((position.x + 1.0) / 2.0) * _36.uWidth) + _36.uX) * 2.0) - 1.0, (((((position.y + 1.0) / 2.0) * _36.uHeight) + _36.uY) * 2.0) - 1.0, 0.0, 1.0);
}


#version 100
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

uniform sampler2D uTexture;

varying vec2 vTexcoord0;
varying vec4 vColor;

void main()
{
    vec4 tex = texture2D(uTexture, vTexcoord0);
    gl_FragData[0] = vec4(vColor.xyz * tex.xyz, tex.w * vColor.w);
}


