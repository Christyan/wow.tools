#version 100
precision mediump float;
precision highp int;

uniform vec4 _65_uViewUp;
uniform vec4 _65_uSunDir_FogStart;
uniform vec4 _65_uSunColor_uFogEnd;
uniform vec4 _65_uAmbientLight;
uniform vec4 _65_FogColor;
uniform int _65_uNewFormula;
uniform sampler2D uDiffuseTexture;
uniform sampler2D uNormalTexture;

varying vec2 vChunkCoords;
varying vec3 vPosition;

void main()
{
    vec2 TextureCoords = vec2(vChunkCoords.x, vChunkCoords.y);
    vec4 texDiffuse = texture2D(uDiffuseTexture, TextureCoords);
    vec3 matDiffuse = texDiffuse.xyz;
    vec3 vNormal = (texture2D(uNormalTexture, TextureCoords).xyz * 2.0) - vec3(1.0);
    vNormal = vec3(-vNormal.z, -vNormal.x, vNormal.y);
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 fogColor = _65_FogColor.xyz;
    float fog_start = _65_uSunDir_FogStart.w;
    float fog_end = _65_uSunColor_uFogEnd.w;
    float fog_rate = 1.5;
    float fog_bias = 0.00999999977648258209228515625;
    float distanceToCamera = length(vPosition);
    float z_depth = distanceToCamera - fog_bias;
    float expFog = 1.0 / exp(max(0.0, z_depth - fog_start) * fog_rate);
    float heightFog = 1.0;
    expFog += heightFog;
    float endFadeFog = clamp((fog_end - distanceToCamera) / (0.699999988079071044921875 * fog_end), 0.0, 1.0);
    vec3 _123 = mix(fogColor, finalColor.xyz, vec3(min(expFog, endFadeFog)));
    finalColor = vec4(_123.x, _123.y, _123.z, finalColor.w);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

uniform vec3 _55_uPos;
uniform mat4 _55_uLookAtMat;
uniform mat4 _55_uPMatrix;
attribute float aIndex;
attribute float aHeight;
varying vec2 vChunkCoords;
varying vec3 vPosition;

void main()
{
    float stepX = floor(aIndex / 16641.0);
    float division = 129.0;
    bool _20 = stepX > 0.100000001490116119384765625;
    if (_20)
    {
        division = 128.0;
    }
    float offset = (stepX * 129.0) * 129.0;
    float iX = mod(aIndex - offset, division) + (stepX * 0.5);
    float iY = floor((aIndex - offset) / division) + (stepX * 0.5);
    vec4 worldPoint = vec4(_55_uPos.x - (iY * 4.166666507720947265625), _55_uPos.y - (iX * 4.166666507720947265625), aHeight, 1.0);
    vChunkCoords = vec2(iX / 128.0, iY / 128.0);
    vPosition = (_55_uLookAtMat * worldPoint).xyz;
    gl_Position = (_55_uPMatrix * _55_uLookAtMat) * worldPoint;
}


#version 100
precision mediump float;
precision highp int;

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

uniform vec4 _466_uHeightScale;
uniform vec4 _466_uHeightOffset;
uniform mat4 _466_animationMat[4];
uniform ivec4 _506_uUseHeightMixFormula;
uniform mat4 _748_scene_uLookAtMat;
uniform mat4 _748_scene_uPMatrix;
uniform vec4 _748_scene_uViewUp;
uniform vec4 _748_scene_uInteriorSunDir;
uniform vec4 _748_scene_extLight_uExteriorAmbientColor;
uniform vec4 _748_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _748_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _748_scene_extLight_uExteriorDirectColor;
uniform vec4 _748_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _748_scene_extLight_adtSpecMult;
uniform vec4 _748_fogData_densityParams;
uniform vec4 _748_fogData_heightPlane;
uniform vec4 _748_fogData_color_and_heightRate;
uniform vec4 _748_fogData_heightDensity_and_endColor;
uniform vec4 _748_fogData_sunAngle_and_sunColor;
uniform vec4 _748_fogData_heightColor_and_endFogDistance;
uniform vec4 _748_fogData_sunPercentage;
uniform sampler2D uAlphaTexture;
uniform sampler2D uLayerHeight0;
uniform sampler2D uLayerHeight1;
uniform sampler2D uLayerHeight2;
uniform sampler2D uLayerHeight3;
uniform sampler2D uLayer0;
uniform sampler2D uLayer1;
uniform sampler2D uLayer2;
uniform sampler2D uLayer3;

varying vec2 vChunkCoords;
varying vec4 vColor;
varying vec3 vNormal;
varying vec3 vVertexLighting;
varying vec3 vPosition;

vec4 mixTextures(vec4 tex0, vec4 tex1, float alpha)
{
    return ((tex1 - tex0) * alpha) + tex0;
}

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular, vec3 emissive)
{
    vec3 localDiffuse = accumLight;
    bool _58 = !applyLight;
    if (_58)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _74 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_74)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _111 = nDotUp >= 0.0;
        if (_111)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _151 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_151)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _175 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_175)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = emissive;
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 validateFogColor(in vec3 fogColor, int blendMode) {
    return fogColor;
}
vec4 makeFog(PSFog fogData, vec4 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    float alpha = 1.0;
    bool _317 = blendMode == 13;
    if (_317)
    {
        alpha = min(finalFog, endFadeFog);
    }
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _395 = nDotSun > 0.0;
    if (_395)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final.xyz, vec3(min(finalFog, endFadeFog)));
    return vec4(fogFinal, final.w * alpha);
}

void main()
{
    vec2 vTexCoord = vChunkCoords;
    vec2 alphaCoord = vec2(vChunkCoords.x / 8.0, vChunkCoords.y / 8.0);
    vec3 alphaBlend = texture2D(uAlphaTexture, alphaCoord).yzw;
    vec2 tcLayer0 = (_466_animationMat[0] * vec4(vTexCoord, 0.0, 1.0)).xy;
    vec2 tcLayer1 = (_466_animationMat[1] * vec4(vTexCoord, 0.0, 1.0)).xy;
    vec2 tcLayer2 = (_466_animationMat[2] * vec4(vTexCoord, 0.0, 1.0)).xy;
    vec2 tcLayer3 = (_466_animationMat[3] * vec4(vTexCoord, 0.0, 1.0)).xy;
    bool _510 = _506_uUseHeightMixFormula.x > 0;
    vec4 final;
    if (_510)
    {
        float minusAlphaBlendSum = 1.0 - clamp(dot(alphaBlend, vec3(1.0)), 0.0, 1.0);
        vec4 weightsVector = vec4(minusAlphaBlendSum, alphaBlend);
        float weightedTexture_x = minusAlphaBlendSum * ((texture2D(uLayerHeight0, tcLayer0).w * _466_uHeightScale.x) + _466_uHeightOffset.x);
        float weightedTexture_y = weightsVector.y * ((texture2D(uLayerHeight1, tcLayer1).w * _466_uHeightScale.y) + _466_uHeightOffset.y);
        float weightedTexture_z = weightsVector.z * ((texture2D(uLayerHeight2, tcLayer2).w * _466_uHeightScale.z) + _466_uHeightOffset.z);
        float weightedTexture_w = weightsVector.w * ((texture2D(uLayerHeight3, tcLayer3).w * _466_uHeightScale.w) + _466_uHeightOffset.w);
        vec4 weights = vec4(weightedTexture_x, weightedTexture_y, weightedTexture_z, weightedTexture_w);
        vec4 weights_temp = weights * (vec4(1.0) - clamp(vec4(max(max(weightedTexture_x, weightedTexture_y), max(weightedTexture_z, weightedTexture_w))) - weights, vec4(0.0), vec4(1.0)));
        vec4 weightsNormalized = weights_temp / vec4(dot(vec4(1.0), weights_temp));
        vec4 weightedLayer_0 = texture2D(uLayer0, tcLayer0) * weightsNormalized.x;
        vec3 matDiffuse_0 = weightedLayer_0.xyz;
        float specBlend_0 = weightedLayer_0.w;
        vec4 weightedLayer_1 = texture2D(uLayer1, tcLayer1) * weightsNormalized.y;
        vec3 matDiffuse_1 = matDiffuse_0 + weightedLayer_1.xyz;
        float specBlend_1 = specBlend_0 + weightedLayer_1.w;
        vec4 weightedLayer_2 = texture2D(uLayer2, tcLayer2) * weightsNormalized.z;
        vec3 matDiffuse_2 = matDiffuse_1 + weightedLayer_2.xyz;
        float specBlend_2 = specBlend_1 + weightedLayer_2.w;
        vec4 weightedLayer_3 = texture2D(uLayer3, tcLayer3) * weightsNormalized.w;
        vec3 matDiffuse_3 = matDiffuse_2 + weightedLayer_3.xyz;
        float specBlend_3 = specBlend_2 + weightedLayer_3.w;
        final = vec4(matDiffuse_3, specBlend_3);
    }
    else
    {
        vec4 tex1 = texture2D(uLayer0, tcLayer0);
        vec4 tex2 = texture2D(uLayer1, tcLayer1);
        vec4 tex3 = texture2D(uLayer2, tcLayer2);
        vec4 tex4 = texture2D(uLayer3, tcLayer3);
        vec4 param = tex1;
        vec4 param_1 = tex2;
        float param_2 = alphaBlend.x;
        vec4 param_3 = mixTextures(param, param_1, param_2);
        vec4 param_4 = tex3;
        float param_5 = alphaBlend.y;
        vec4 param_6 = mixTextures(param_3, param_4, param_5);
        vec4 param_7 = tex4;
        float param_8 = alphaBlend.z;
        final = mixTextures(param_6, param_7, param_8);
    }
    vec3 matDiffuse = (final.xyz * 2.0) * vColor.xyz;
    vec3 param_9 = matDiffuse;
    vec3 param_10 = vNormal;
    bool param_11 = true;
    float param_12 = 0.0;
    SceneWideParams param_13;
    param_13.uLookAtMat = _748_scene_uLookAtMat;
    param_13.uPMatrix = _748_scene_uPMatrix;
    param_13.uViewUp = _748_scene_uViewUp;
    param_13.uInteriorSunDir = _748_scene_uInteriorSunDir;
    param_13.extLight.uExteriorAmbientColor = _748_scene_extLight_uExteriorAmbientColor;
    param_13.extLight.uExteriorHorizontAmbientColor = _748_scene_extLight_uExteriorHorizontAmbientColor;
    param_13.extLight.uExteriorGroundAmbientColor = _748_scene_extLight_uExteriorGroundAmbientColor;
    param_13.extLight.uExteriorDirectColor = _748_scene_extLight_uExteriorDirectColor;
    param_13.extLight.uExteriorDirectColorDir = _748_scene_extLight_uExteriorDirectColorDir;
    param_13.extLight.adtSpecMult = _748_scene_extLight_adtSpecMult;
    InteriorLightParam param_14 = InteriorLightParam(vec4(0.0), vec4(0.0, 0.0, 0.0, 1.0));
    vec3 param_15 = vVertexLighting;
    vec4 finalColor = vec4(calcLight(param_9, param_10, param_11, param_12, param_13, param_14, param_15, vec3(0.0), vec3(0.0), vec3(0.0)), 1.0);
    float specBlend = final.w;
    vec3 halfVec = -normalize(_748_scene_extLight_uExteriorDirectColorDir.xyz + normalize(vPosition));
    vec3 lSpecular = _748_scene_extLight_uExteriorDirectColor.xyz * pow(max(0.0, dot(halfVec, vNormal)), 20.0);
    vec3 specTerm = (vec3(specBlend) * lSpecular) * _748_scene_extLight_adtSpecMult.x;
    vec3 _831 = finalColor.xyz + specTerm;
    finalColor = vec4(_831.x, _831.y, _831.z, finalColor.w);
    PSFog arg;
    arg.densityParams = _748_fogData_densityParams;
    arg.heightPlane = _748_fogData_heightPlane;
    arg.color_and_heightRate = _748_fogData_color_and_heightRate;
    arg.heightDensity_and_endColor = _748_fogData_heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _748_fogData_sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _748_fogData_heightColor_and_endFogDistance;
    arg.sunPercentage = _748_fogData_sunPercentage;
    vec4 param_16 = finalColor;
    vec3 param_17 = vPosition;
    vec3 param_18 = _748_scene_extLight_uExteriorDirectColorDir.xyz;
    int param_19 = 0;
    finalColor = makeFog(arg, param_16, param_17, param_18, param_19);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

uniform mat4 _91_scene_uLookAtMat;
uniform mat4 _91_scene_uPMatrix;
uniform vec4 _91_scene_uViewUp;
uniform vec4 _91_scene_uInteriorSunDir;
uniform vec4 _91_scene_extLight_uExteriorAmbientColor;
uniform vec4 _91_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _91_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _91_scene_extLight_uExteriorDirectColor;
uniform vec4 _91_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _91_scene_extLight_adtSpecMult;
uniform vec4 _91_fogData_densityParams;
uniform vec4 _91_fogData_heightPlane;
uniform vec4 _91_fogData_color_and_heightRate;
uniform vec4 _91_fogData_heightDensity_and_endColor;
uniform vec4 _91_fogData_sunAngle_and_sunColor;
uniform vec4 _91_fogData_heightColor_and_endFogDistance;
uniform vec4 _91_fogData_sunPercentage;
uniform vec4 _139_uPos;
attribute float aIndex;
attribute vec3 aHeight;
varying vec2 vChunkCoords;
varying vec3 vPosition;
varying vec4 vColor;
attribute vec4 aColor;
varying vec3 vVertexLighting;
attribute vec4 aVertexLighting;
varying vec3 vNormal;
attribute vec3 aNormal;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

void main()
{
    float iX = mod(aIndex, 17.0);
    float iY = floor(aIndex / 17.0);
    bool _61 = iX > 8.0100002288818359375;
    if (_61)
    {
        iY += 0.5;
        iX -= 8.5;
    }
    vec4 worldPoint = vec4(aHeight, 1.0);
    vChunkCoords = vec2(iX, iY);
    vPosition = (_91_scene_uLookAtMat * worldPoint).xyz;
    vColor = aColor;
    vVertexLighting = aVertexLighting.xyz;
    mat4 param = _91_scene_uLookAtMat;
    vNormal = blizzTranspose(param) * aNormal;
    gl_Position = (_91_scene_uPMatrix * _91_scene_uLookAtMat) * worldPoint;
}


#version 100
precision mediump float;
precision highp int;

uniform mat4 _13_uPlacementMat;
uniform vec4 _13_uBBScale;
uniform vec4 _13_uBBCenter;
uniform vec4 _13_uColor;
void main()
{
    vec4 finalColor = _13_uColor;
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

uniform mat4 _21_uPlacementMat;
uniform vec4 _21_uBBScale;
uniform vec4 _21_uBBCenter;
uniform vec4 _21_uColor;
uniform mat4 _62_scene_uLookAtMat;
uniform mat4 _62_scene_uPMatrix;
uniform vec4 _62_scene_uViewUp;
uniform vec4 _62_scene_uInteriorSunDir;
uniform vec4 _62_scene_extLight_uExteriorAmbientColor;
uniform vec4 _62_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _62_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _62_scene_extLight_uExteriorDirectColor;
uniform vec4 _62_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _62_scene_extLight_adtSpecMult;
uniform vec4 _62_fogData_densityParams;
uniform vec4 _62_fogData_heightPlane;
uniform vec4 _62_fogData_color_and_heightRate;
uniform vec4 _62_fogData_heightDensity_and_endColor;
uniform vec4 _62_fogData_sunAngle_and_sunColor;
uniform vec4 _62_fogData_heightColor_and_endFogDistance;
uniform vec4 _62_fogData_sunPercentage;
attribute vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4((aPosition.x * _21_uBBScale.x) + _21_uBBCenter.x, (aPosition.y * _21_uBBScale.y) + _21_uBBCenter.y, (aPosition.z * _21_uBBScale.z) + _21_uBBCenter.z, 1.0);
    gl_Position = ((_62_scene_uPMatrix * _62_scene_uLookAtMat) * _21_uPlacementMat) * worldPoint;
}


#version 100
precision mediump float;
precision highp int;

uniform int _10_drawDepth;
uniform float _10_uFarPlane;
uniform float _10_uNearPlane;
uniform sampler2D diffuse;

varying vec2 texCoord;

void main()
{
    bool _17 = _10_drawDepth == 1;
    vec4 finalColor;
    if (_17)
    {
        float f = _10_uFarPlane;
        float n = _10_uNearPlane;
        float z = (2.0 * n) / ((f + n) - (texture2D(diffuse, texCoord).x * (f - n)));
        finalColor = vec4(z, z, z, 255.0);
    }
    else
    {
        finalColor = vec4(texture2D(diffuse, texCoord).xyz, 255.0);
    }
    gl_FragData[0] = finalColor;
}


#version 100
precision mediump float;
precision highp int;

uniform vec3 _22_uColor;
void main()
{
    vec4 finalColor = vec4(1.0);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

uniform mat4 _13_uLookAtMat;
uniform mat4 _13_uPMatrix;
attribute vec3 aPosition;

void main()
{
    vec4 c_world = inverse(_13_uPMatrix) * vec4(aPosition, 1.0);
    c_world = (c_world * 1.0) / vec4(c_world.w);
    gl_Position = (_13_uPMatrix * _13_uLookAtMat) * vec4(c_world.xyz, 1.0);
}


#version 100
precision mediump float;
precision highp int;

uniform vec3 _19_uColor;
void main()
{
    vec4 finalColor = vec4(1.0, 1.0, 0.0, 1.0);
    gl_FragData[0] = finalColor;
}


#version 100

uniform mat4 _19_uLookAtMat;
uniform mat4 _19_uPMatrix;
attribute vec2 aPosition;

void main()
{
    gl_Position = (_19_uPMatrix * _19_uLookAtMat) * vec4(aPosition, 0.0, 1.0);
}


#version 100
precision mediump float;
precision highp int;

uniform vec3 _13_uColor;
varying vec4 vPos;

void main()
{
    gl_FragData[0] = vec4(_13_uColor, 1.0);
}


#version 100

uniform mat4 _19_uLookAtMat;
uniform mat4 _19_uPMatrix;
uniform mat4 _29_uPlacementMat;
attribute vec3 aPosition;
varying vec4 vPos;

void main()
{
    gl_Position = ((_19_uPMatrix * _19_uLookAtMat) * _29_uPlacementMat) * vec4(aPosition, 1.0);
    gl_PointSize = 10.0;
}


#version 100
precision mediump float;
precision highp int;

uniform vec4 _12_uColor;
void main()
{
    vec4 finalColor = _12_uColor;
    gl_FragData[0] = finalColor;
}


#version 100

uniform mat4 _30_uLookAtMat;
uniform mat4 _30_uPMatrix;
attribute vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4(aPosition, 1.0);
    gl_Position = (_30_uPMatrix * _30_uLookAtMat) * worldPoint;
}


#version 100

uniform vec4 _12_uWidth_uHeight_uX_uY;
varying vec2 texCoord;
attribute vec2 position;

void main()
{
    float uWidth = _12_uWidth_uHeight_uX_uY.x;
    float uHeight = _12_uWidth_uHeight_uX_uY.y;
    float uX = _12_uWidth_uHeight_uX_uY.z;
    float uY = _12_uWidth_uHeight_uX_uY.w;
    texCoord = (position * 0.5) + vec2(0.5);
    gl_Position = vec4((((((position.x + 1.0) / 2.0) * uWidth) + uX) * 2.0) - 1.0, (((((position.y + 1.0) / 2.0) * uHeight) + uY) * 2.0) - 1.0, 0.5, 1.0);
}


#version 100
precision mediump float;
precision highp int;

uniform vec4 _33_texOffsetX;
uniform vec4 _33_texOffsetY;
uniform sampler2D texture0;

varying vec2 texCoord;

void main()
{
    vec2 tex_offset = vec2(0.001000000047497451305389404296875);
    vec3 result = texture2D(texture0, texCoord).xyz * 0.0;
    result = vec3(0.0);
    result += (texture2D(texture0, texCoord + vec2(_33_texOffsetX.x * tex_offset.x, _33_texOffsetY.x * tex_offset.y)).xyz * 0.125);
    result += (texture2D(texture0, texCoord + vec2(_33_texOffsetX.y * tex_offset.x, _33_texOffsetY.y * tex_offset.y)).xyz * 0.375);
    result += (texture2D(texture0, texCoord + vec2(_33_texOffsetX.z * tex_offset.x, _33_texOffsetY.z * tex_offset.y)).xyz * 0.375);
    result += (texture2D(texture0, texCoord + vec2(_33_texOffsetX.w * tex_offset.x, _33_texOffsetY.w * tex_offset.y)).xyz * 0.125);
    gl_FragData[0] = vec4(result, 1.0);
}


#version 100
precision mediump float;
precision highp int;

uniform vec4 _34_blurAmount;
uniform sampler2D screenTex;
uniform sampler2D blurTex;

varying vec2 texCoord;

void main()
{
    vec4 screen = texture2D(screenTex, texCoord);
    vec3 blurred = texture2D(blurTex, texCoord).xyz;
    vec3 mixed = mix(screen.xyz, blurred, vec3(_34_blurAmount.z));
    vec3 glow = (blurred * blurred) * _34_blurAmount.w;
    gl_FragData[0] = vec4(mixed + glow, screen.w);
}


#version 100
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif
precision mediump float;
precision highp int;

uniform sampler2D Texture;

varying vec4 Frag_Color;
varying vec2 Frag_UV;

void main()
{
    gl_FragData[0] = Frag_Color * texture2D(Texture, Frag_UV);
}


#version 100

uniform mat4 _30_ProjMtx;
uniform vec4 _30_uiScale;
varying vec2 Frag_UV;
attribute vec2 UV;
varying vec4 Frag_Color;
attribute vec4 Color;
attribute vec2 Position;

void main()
{
    Frag_UV = UV;
    Frag_Color = Color;
    gl_Position = _30_ProjMtx * vec4(Position * _30_uiScale.x, 0.0, 1.0);
}


#version 100
precision mediump float;
precision highp int;

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

uniform vec4 _277_uAlphaTestv;
uniform ivec4 _277_uPixelShaderBlendModev;
uniform mat4 _485_scene_uLookAtMat;
uniform mat4 _485_scene_uPMatrix;
uniform vec4 _485_scene_uViewUp;
uniform vec4 _485_scene_uInteriorSunDir;
uniform vec4 _485_scene_extLight_uExteriorAmbientColor;
uniform vec4 _485_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _485_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _485_scene_extLight_uExteriorDirectColor;
uniform vec4 _485_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _485_scene_extLight_adtSpecMult;
uniform vec4 _485_fogData_densityParams;
uniform vec4 _485_fogData_heightPlane;
uniform vec4 _485_fogData_color_and_heightRate;
uniform vec4 _485_fogData_heightDensity_and_endColor;
uniform vec4 _485_fogData_sunAngle_and_sunColor;
uniform vec4 _485_fogData_heightColor_and_endFogDistance;
uniform vec4 _485_fogData_sunPercentage;
uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

varying vec2 vTexcoord0;
varying vec2 vTexcoord1;
varying vec2 vTexcoord2;
varying vec4 vColor;
varying vec3 vPosition;

vec3 validateFogColor(in vec3 fogColor, int blendMode) {
    return fogColor;
}
vec4 makeFog(PSFog fogData, vec4 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    float alpha = 1.0;
    bool _139 = blendMode == 13;
    if (_139)
    {
        alpha = min(finalFog, endFadeFog);
    }
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _218 = nDotSun > 0.0;
    if (_218)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final.xyz, vec3(min(finalFog, endFadeFog)));
    return vec4(fogFinal, final.w * alpha);
}

void main()
{
    vec4 tex = texture2D(uTexture, vTexcoord0);
    vec4 tex2 = texture2D(uTexture2, vTexcoord1);
    vec4 tex3 = texture2D(uTexture3, vTexcoord2);
    float uAlphaTest = _277_uAlphaTestv.x;
    bool _284 = tex.w < uAlphaTest;
    if (_284)
    {
        discard;
    }
    vec4 finalColor = vec4((tex * vColor).xyz, tex.w * vColor.w);
    int uNonOptPixelShader = _277_uPixelShaderBlendModev.x;
    bool _310 = uNonOptPixelShader == 0;
    if (_310)
    {
        vec3 matDiffuse = vColor.xyz * tex.xyz;
        finalColor = vec4(matDiffuse, tex.w * vColor.w);
    }
    else
    {
        bool _331 = uNonOptPixelShader == 1;
        if (_331)
        {
            vec4 textureMod = tex * tex2;
            float texAlpha = textureMod.w * tex3.w;
            float opacity = texAlpha * vColor.w;
            vec3 matDiffuse_1 = vColor.xyz * textureMod.xyz;
            finalColor = vec4(matDiffuse_1, opacity);
        }
        else
        {
            bool _363 = uNonOptPixelShader == 2;
            if (_363)
            {
                vec4 textureMod_1 = (tex * tex2) * tex3;
                float texAlpha_1 = textureMod_1.w;
                float opacity_1 = texAlpha_1 * vColor.w;
                vec3 matDiffuse_2 = vColor.xyz * textureMod_1.xyz;
                finalColor = vec4(matDiffuse_2, opacity_1);
            }
            else
            {
                bool _394 = uNonOptPixelShader == 3;
                if (_394)
                {
                    vec4 textureMod_2 = (tex * tex2) * tex3;
                    float texAlpha_2 = textureMod_2.w;
                    float opacity_2 = texAlpha_2 * vColor.w;
                    vec3 matDiffuse_3 = vColor.xyz * textureMod_2.xyz;
                    finalColor = vec4(matDiffuse_3, opacity_2);
                }
                else
                {
                    bool _425 = uNonOptPixelShader == 4;
                    if (_425)
                    {
                        float t0_973 = tex.x;
                        float t1_978 = tex2.y;
                        float t2_983 = tex3.z;
                        float textureMod_986 = ((t0_973 * t1_978) * t2_983) * 4.0;
                        float depthScale_991 = 1.0 - clamp(vPosition.z * 0.00999999977648258209228515625, 0.0, 1.0);
                        float textureMod_992 = textureMod_986 * depthScale_991;
                        float height_995 = textureMod_992 * vColor.x;
                        float alpha_997 = textureMod_992 * vColor.w;
                        finalColor = vec4(height_995, 0.0, 0.0, alpha_997);
                    }
                }
            }
        }
    }
    bool _474 = finalColor.w < uAlphaTest;
    if (_474)
    {
        discard;
    }
    vec3 sunDir = _485_scene_extLight_uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _485_fogData_densityParams;
    arg.heightPlane = _485_fogData_heightPlane;
    arg.color_and_heightRate = _485_fogData_color_and_heightRate;
    arg.heightDensity_and_endColor = _485_fogData_heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _485_fogData_sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _485_fogData_heightColor_and_endFogDistance;
    arg.sunPercentage = _485_fogData_sunPercentage;
    vec4 param = finalColor;
    vec3 param_1 = vPosition;
    vec3 param_2 = sunDir;
    int param_3 = _277_uPixelShaderBlendModev.y;
    finalColor = makeFog(arg, param, param_1, param_2, param_3);
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

uniform mat4 _43_scene_uLookAtMat;
uniform mat4 _43_scene_uPMatrix;
uniform vec4 _43_scene_uViewUp;
uniform vec4 _43_scene_uInteriorSunDir;
uniform vec4 _43_scene_extLight_uExteriorAmbientColor;
uniform vec4 _43_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _43_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _43_scene_extLight_uExteriorDirectColor;
uniform vec4 _43_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _43_scene_extLight_adtSpecMult;
uniform vec4 _43_fogData_densityParams;
uniform vec4 _43_fogData_heightPlane;
uniform vec4 _43_fogData_color_and_heightRate;
uniform vec4 _43_fogData_heightDensity_and_endColor;
uniform vec4 _43_fogData_sunAngle_and_sunColor;
uniform vec4 _43_fogData_heightColor_and_endFogDistance;
uniform vec4 _43_fogData_sunPercentage;
attribute vec3 aPosition;
varying vec4 vColor;
attribute vec4 aColor;
varying vec2 vTexcoord0;
attribute vec2 aTexcoord0;
varying vec2 vTexcoord1;
attribute vec2 aTexcoord1;
varying vec2 vTexcoord2;
attribute vec2 aTexcoord2;
varying vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vTexcoord1 = aTexcoord1;
    vTexcoord2 = aTexcoord2;
    vec4 vertexViewSpace = _43_scene_uLookAtMat * aPositionVec4;
    vPosition = vertexViewSpace.xyz;
    gl_Position = _43_scene_uPMatrix * vertexViewSpace;
}


#version 100
precision mediump float;
precision highp int;

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct LocalLight
{
    vec4 color;
    vec4 position;
    vec4 attenuation;
};

uniform ivec4 _473_PixelShader_UnFogged_IsAffectedByLight_blendMode;
uniform vec4 _473_uFogColorAndAlphaTest;
uniform vec4 _473_uTexSampleAlpha;
uniform vec4 _473_uPcColor;
uniform vec4 _496_intLight_uInteriorAmbientColorAndApplyInteriorLight;
uniform vec4 _496_intLight_uInteriorDirectColorAndApplyExteriorLight;
uniform LocalLight _496_pc_lights[4];
uniform ivec4 _496_lightCountAndBcHack;
uniform vec4 _496_interiorExteriorBlend;
uniform mat4 _535_scene_uLookAtMat;
uniform mat4 _535_scene_uPMatrix;
uniform vec4 _535_scene_uViewUp;
uniform vec4 _535_scene_uInteriorSunDir;
uniform vec4 _535_scene_extLight_uExteriorAmbientColor;
uniform vec4 _535_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _535_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _535_scene_extLight_uExteriorDirectColor;
uniform vec4 _535_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _535_scene_extLight_adtSpecMult;
uniform vec4 _535_fogData_densityParams;
uniform vec4 _535_fogData_heightPlane;
uniform vec4 _535_fogData_color_and_heightRate;
uniform vec4 _535_fogData_heightDensity_and_endColor;
uniform vec4 _535_fogData_sunAngle_and_sunColor;
uniform vec4 _535_fogData_heightColor_and_endFogDistance;
uniform vec4 _535_fogData_sunPercentage;
uniform mat4 _543_uPlacementMat;
uniform mat4 _543_uBoneMatrixes[220];
uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;
uniform sampler2D uTexture4;

varying vec2 vTexCoord;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vDiffuseColor;
varying vec3 vPosition;
varying vec3 vNormal;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular, vec3 emissive)
{
    vec3 localDiffuse = accumLight;
    bool _52 = !applyLight;
    if (_52)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _68 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_68)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _105 = nDotUp >= 0.0;
        if (_105)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _145 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_145)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _169 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_169)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = emissive;
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 validateFogColor(in vec3 fogColor, int blendMode) {
    return fogColor;
}
vec4 makeFog(PSFog fogData, vec4 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    float alpha = 1.0;
    bool _311 = blendMode == 13;
    if (_311)
    {
        alpha = min(finalFog, endFadeFog);
    }
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _389 = nDotSun > 0.0;
    if (_389)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final.xyz, vec3(min(finalFog, endFadeFog)));
    return vec4(fogFinal, final.w * alpha);
}

void main()
{
    vec2 texCoord = vTexCoord;
    vec2 texCoord2 = vTexCoord2;
    vec2 texCoord3 = vTexCoord3;
    vec4 tex = texture2D(uTexture, texCoord);
    vec4 tex2 = texture2D(uTexture2, texCoord2);
    vec4 tex3 = texture2D(uTexture3, texCoord3);
    vec4 tex2WithTextCoord1 = texture2D(uTexture2, texCoord);
    vec4 tex3WithTextCoord1 = texture2D(uTexture3, texCoord);
    vec4 tex4WithTextCoord2 = texture2D(uTexture4, texCoord2);
    vec4 finalColor = vec4(0.0);
    vec4 meshResColor = vDiffuseColor;
    bool _477 = _473_PixelShader_UnFogged_IsAffectedByLight_blendMode.z == 1;
    vec3 accumLight;
    if (_477)
    {
        vec3 vPos3 = vPosition;
        vec3 vNormal3 = normalize(vNormal);
        vec3 lightColor = vec3(0.0);
        int count = int(_496_pc_lights[0].attenuation.w);
        LocalLight lightRecord;
        for (int index = 0; index < 4; index++)
        {
            bool _512 = index >= _496_lightCountAndBcHack.x;
            if (_512)
            {
                break;
            }
            lightRecord.color = _496_pc_lights[index].color;
            lightRecord.position = _496_pc_lights[index].position;
            lightRecord.attenuation = _496_pc_lights[index].attenuation;
            vec3 vectorToLight = (_535_scene_uLookAtMat * (_543_uPlacementMat * lightRecord.position)).xyz - vPos3;
            float distanceToLightSqr = dot(vectorToLight, vectorToLight);
            float distanceToLightInv = inversesqrt(distanceToLightSqr);
            float distanceToLight = distanceToLightSqr * distanceToLightInv;
            float diffuseTerm1 = max(dot(vectorToLight, vNormal3) * distanceToLightInv, 0.0);
            vec4 attenuationRec = lightRecord.attenuation;
            float attenuation = 1.0 - clamp((distanceToLight - attenuationRec.x) * (1.0 / (attenuationRec.z - attenuationRec.x)), 0.0, 1.0);
            vec3 attenuatedColor = lightRecord.color.xyz * attenuation;
            lightColor += vec3((attenuatedColor * attenuatedColor) * diffuseTerm1);
        }
        vec3 _610 = clamp(lightColor, vec3(0.0), vec3(1.0));
        meshResColor = vec4(_610.x, _610.y, _610.z, meshResColor.w);
        accumLight = mix(lightColor, meshResColor.xyz, vec3(float(_496_lightCountAndBcHack.y)));
    }
    float finalOpacity = 0.0;
    vec3 specular = vec3(0.0);
    vec3 visParams = vec3(1.0);
    vec4 genericParams[3];
    genericParams[0] = vec4(1.0);
    genericParams[1] = vec4(1.0);
    genericParams[2] = vec4(1.0);
    bool canDiscard = false;
    float discardAlpha = 1.0;
    int uPixelShader = _473_PixelShader_UnFogged_IsAffectedByLight_blendMode.x;
    bool _639 = uPixelShader == 0;
    vec3 matDiffuse;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    #endif
    bool _652 = uPixelShader == 1;
    #if (FRAGMENTSHADER == 1)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w;
    canDiscard = true;
    #endif
    bool _666 = uPixelShader == 2;
    #if (FRAGMENTSHADER == 2)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    discardAlpha = tex2.w;
    canDiscard = true;
    #endif
    bool _682 = uPixelShader == 3;
    #if (FRAGMENTSHADER == 3)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    discardAlpha = tex2.w * 2.0;
    canDiscard = true;
    #endif
    bool _700 = uPixelShader == 4;
    #if (FRAGMENTSHADER == 4)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    #endif
    bool _715 = uPixelShader == 5;
    #if (FRAGMENTSHADER == 5)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    #endif
    bool _729 = uPixelShader == 6;
    #if (FRAGMENTSHADER == 6)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    discardAlpha = tex.w * tex2.w;
    canDiscard = true;
    #endif
    bool _749 = uPixelShader == 7;
    #if (FRAGMENTSHADER == 7)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    discardAlpha = (tex.w * tex2.w) * 2.0;
    canDiscard = true;
    #endif
    bool _771 = uPixelShader == 8;
    #if (FRAGMENTSHADER == 8)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w + tex2.w;
    canDiscard = true;
    specular = tex2.xyz;
    #endif
    bool _790 = uPixelShader == 9;
    #if (FRAGMENTSHADER == 9)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    discardAlpha = tex.w;
    canDiscard = true;
    #endif
    bool _808 = uPixelShader == 10;
    #if (FRAGMENTSHADER == 10)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w;
    canDiscard = true;
    specular = tex2.xyz;
    #endif
    bool _824 = uPixelShader == 11;
    #if (FRAGMENTSHADER == 11)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    discardAlpha = tex.w;
    canDiscard = true;
    #endif
    bool _841 = uPixelShader == 12;
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    #endif
    bool _862 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = tex2.xyz * tex2.w;
    #endif
    bool _879 = uPixelShader == 14;
    #if (FRAGMENTSHADER == 14)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    #endif
    bool _900 = uPixelShader == 15;
    #if (FRAGMENTSHADER == 15)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    specular = (tex3.xyz * tex3.w) * _473_uTexSampleAlpha.z;
    #endif
    bool _930 = uPixelShader == 16;
    #if (FRAGMENTSHADER == 16)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w;
    canDiscard = true;
    specular = tex2.xyz * tex2.w;
    #endif
    bool _949 = uPixelShader == 17;
    #if (FRAGMENTSHADER == 17)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w + (tex2.w * (((0.300000011920928955078125 * tex2.x) + (0.589999973773956298828125 * tex2.y)) + (0.10999999940395355224609375 * tex2.z)));
    canDiscard = true;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    #endif
    bool _990 = uPixelShader == 18;
    #if (FRAGMENTSHADER == 18)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex.xyz, tex2.xyz, vec3(tex2.w)), tex.xyz, vec3(tex.w));
    #endif
    bool _1014 = uPixelShader == 19;
    #if (FRAGMENTSHADER == 19)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w));
    #endif
    bool _1036 = uPixelShader == 20;
    #if (FRAGMENTSHADER == 20)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * _473_uTexSampleAlpha.y;
    #endif
    bool _1056 = uPixelShader == 21;
    #if (FRAGMENTSHADER == 21)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w + tex2.w;
    canDiscard = true;
    specular = tex2.xyz * (1.0 - tex.w);
    #endif
    bool _1079 = uPixelShader == 22;
    #if (FRAGMENTSHADER == 22)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * tex2.xyz, tex.xyz, vec3(tex.w));
    #endif
    bool _1100 = uPixelShader == 23;
    #if (FRAGMENTSHADER == 23)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w;
    canDiscard = true;
    specular = (tex2.xyz * tex2.w) * _473_uTexSampleAlpha.y;
    #endif
    bool _1122 = uPixelShader == 24;
    #if (FRAGMENTSHADER == 24)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    specular = (tex.xyz * tex.w) * _473_uTexSampleAlpha.x;
    #endif
    bool _1148 = uPixelShader == 25;
    #if (FRAGMENTSHADER == 25)
    float glowOpacity = clamp(tex3.w * _473_uTexSampleAlpha.z, 0.0, 1.0);
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w))) * (1.0 - glowOpacity);
    specular = tex3.xyz * glowOpacity;
    #endif
    bool _1184 = uPixelShader == 26;
    #if (FRAGMENTSHADER == 26)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_473_uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_473_uTexSampleAlpha.z, 0.0, 1.0))).xyz;
    discardAlpha = mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_473_uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_473_uTexSampleAlpha.z, 0.0, 1.0))).w;
    canDiscard = true;
    #endif
    bool _1222 = uPixelShader == 27;
    #if (FRAGMENTSHADER == 27)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w)), tex.xyz, vec3(tex.w));
    #endif
    bool _1250 = uPixelShader == 28;
    #if (FRAGMENTSHADER == 28)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_473_uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_473_uTexSampleAlpha.z, 0.0, 1.0))).xyz;
    discardAlpha = mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_473_uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_473_uTexSampleAlpha.z, 0.0, 1.0))).w * tex4WithTextCoord2.w;
    canDiscard = true;
    #endif
    bool _1291 = uPixelShader == 29;
    #if (FRAGMENTSHADER == 29)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    #endif
    bool _1309 = uPixelShader == 30;
    #if (FRAGMENTSHADER == 30)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    discardAlpha = tex.w;
    canDiscard = true;
    #endif
    bool _1347 = uPixelShader == 31;
    #if (FRAGMENTSHADER == 31)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w));
    discardAlpha = tex.w;
    canDiscard = true;
    #endif
    bool _1375 = uPixelShader == 32;
    #if (FRAGMENTSHADER == 32)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    #endif
    bool _1411 = uPixelShader == 33;
    #if (FRAGMENTSHADER == 33)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w;
    canDiscard = true;
    #endif
    bool _1425 = uPixelShader == 34;
    #if (FRAGMENTSHADER == 34)
    discardAlpha = tex.w;
    canDiscard = true;
    #endif
    bool _1433 = uPixelShader == 35;
    #if (FRAGMENTSHADER == 35)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * (((tex * tex2) * tex3) * genericParams[0]).xyz;
    discardAlpha = (((tex * tex2) * tex3) * genericParams[0]).w;
    canDiscard = true;
    #endif
    bool _1461 = uPixelShader == 36;
    #if (FRAGMENTSHADER == 36)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    discardAlpha = tex.w * tex2.w;
    canDiscard = true;
    #endif
    int blendMode = _473_PixelShader_UnFogged_IsAffectedByLight_blendMode.w;
    bool _1482 = blendMode == 13;
    if (_1482)
    {
        finalOpacity = discardAlpha * vDiffuseColor.w;
    }
    else
    {
        bool _1492 = blendMode == 1;
        if (_1492)
        {
            finalOpacity = vDiffuseColor.w;
            bool _1501 = canDiscard && (discardAlpha < 0.501960813999176025390625);
            if (_1501)
            {
                discard;
            }
            finalOpacity = vDiffuseColor.w;
        }
        else
        {
            bool _1509 = blendMode == 0;
            if (_1509)
            {
                finalOpacity = vDiffuseColor.w;
            }
            else
            {
                finalOpacity = discardAlpha * vDiffuseColor.w;
            }
        }
    }
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = _473_PixelShader_UnFogged_IsAffectedByLight_blendMode.z > 0;
    float param_3 = _496_interiorExteriorBlend.x;
    SceneWideParams param_4;
    param_4.uLookAtMat = _535_scene_uLookAtMat;
    param_4.uPMatrix = _535_scene_uPMatrix;
    param_4.uViewUp = _535_scene_uViewUp;
    param_4.uInteriorSunDir = _535_scene_uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _535_scene_extLight_uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _535_scene_extLight_uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _535_scene_extLight_uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _535_scene_extLight_uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _535_scene_extLight_uExteriorDirectColorDir;
    param_4.extLight.adtSpecMult = _535_scene_extLight_adtSpecMult;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _496_intLight_uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _496_intLight_uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_6 = accumLight;
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vec3(0.0), specular, vec3(0.0)), finalOpacity);
    int uUnFogged = _473_PixelShader_UnFogged_IsAffectedByLight_blendMode.y;
    bool _1579 = uUnFogged == 0;
    if (_1579)
    {
        vec3 sunDir = mix(_535_scene_uInteriorSunDir, _535_scene_extLight_uExteriorDirectColorDir, vec4(_496_interiorExteriorBlend.x)).xyz;
        PSFog arg;
        arg.densityParams = _535_fogData_densityParams;
        arg.heightPlane = _535_fogData_heightPlane;
        arg.color_and_heightRate = _535_fogData_color_and_heightRate;
        arg.heightDensity_and_endColor = _535_fogData_heightDensity_and_endColor;
        arg.sunAngle_and_sunColor = _535_fogData_sunAngle_and_sunColor;
        arg.heightColor_and_endFogDistance = _535_fogData_heightColor_and_endFogDistance;
        arg.sunPercentage = _535_fogData_sunPercentage;
        vec4 param_7 = finalColor;
        vec3 param_8 = vPosition;
        vec3 param_9 = sunDir;
        int param_10 = _473_PixelShader_UnFogged_IsAffectedByLight_blendMode.w;
        finalColor = makeFog(arg, param_7, param_8, param_9, param_10);
    }
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

uniform mat4 _133_uPlacementMat;
uniform mat4 _133_uBoneMatrixes[220];
uniform ivec4 _230_vertexShader_IsAffectedByLight;
uniform vec4 _230_color_Transparency;
uniform mat4 _230_uTextMat[2];
uniform mat4 _240_scene_uLookAtMat;
uniform mat4 _240_scene_uPMatrix;
uniform vec4 _240_scene_uViewUp;
uniform vec4 _240_scene_uInteriorSunDir;
uniform vec4 _240_scene_extLight_uExteriorAmbientColor;
uniform vec4 _240_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _240_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _240_scene_extLight_uExteriorDirectColor;
uniform vec4 _240_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _240_scene_extLight_adtSpecMult;
uniform vec4 _240_fogData_densityParams;
uniform vec4 _240_fogData_heightPlane;
uniform vec4 _240_fogData_color_and_heightRate;
uniform vec4 _240_fogData_heightDensity_and_endColor;
uniform vec4 _240_fogData_sunAngle_and_sunColor;
uniform vec4 _240_fogData_heightColor_and_endFogDistance;
uniform vec4 _240_fogData_sunPercentage;
attribute vec3 aPosition;
attribute vec4 boneWeights;
attribute vec4 bones;
attribute vec3 aNormal;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vDiffuseColor;
varying vec2 vTexCoord;
attribute vec2 aTexCoord;
attribute vec2 aTexCoord2;
varying vec3 vNormal;
varying vec3 vPosition;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

float edgeScan(vec3 position, vec3 normal)
{
    float dotProductClamped = clamp(dot(-normalize(position), normal), 0.0, 1.0);
    return clamp(((2.7000000476837158203125 * dotProductClamped) * dotProductClamped) - 0.4000000059604644775390625, 0.0, 1.0);
}

void main()
{
    vec4 modelPoint = vec4(0.0);
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 boneTransformMat = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0));
    mat4 _143 = _133_uBoneMatrixes[bones.x] * boneWeights.x;
    boneTransformMat = mat4(boneTransformMat[0] + _143[0], boneTransformMat[1] + _143[1], boneTransformMat[2] + _143[2], boneTransformMat[3] + _143[3]);
    mat4 _164 = _133_uBoneMatrixes[bones.y] * boneWeights.y;
    boneTransformMat = mat4(boneTransformMat[0] + _164[0], boneTransformMat[1] + _164[1], boneTransformMat[2] + _164[2], boneTransformMat[3] + _164[3]);
    mat4 _185 = _133_uBoneMatrixes[bones.z] * boneWeights.z;
    boneTransformMat = mat4(boneTransformMat[0] + _185[0], boneTransformMat[1] + _185[1], boneTransformMat[2] + _185[2], boneTransformMat[3] + _185[3]);
    mat4 _207 = _133_uBoneMatrixes[bones.w] * boneWeights.w;
    boneTransformMat = mat4(boneTransformMat[0] + _207[0], boneTransformMat[1] + _207[1], boneTransformMat[2] + _207[2], boneTransformMat[3] + _207[3]);
    mat4 placementMat = _133_uPlacementMat;
    vec4 lDiffuseColor = _230_color_Transparency;
    mat4 cameraMatrix = (_240_scene_uLookAtMat * placementMat) * boneTransformMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    mat4 param = _240_scene_uLookAtMat;
    mat4 param_1 = placementMat;
    mat4 param_2 = boneTransformMat;
    mat3 viewModelMatTransposed = (blizzTranspose(param) * blizzTranspose(param_1)) * blizzTranspose(param_2);
    vec3 normal = normalize(viewModelMatTransposed * aNormal);
    vec4 combinedColor = clamp(lDiffuseColor, vec4(0.0), vec4(1.0));
    vec4 combinedColorHalved = combinedColor * 0.5;
    vec3 param_3 = cameraPoint.xyz;
    vec3 param_4 = normal;
    vec2 envCoord = posToTexCoord(param_3, param_4);
    vec3 param_5 = cameraPoint.xyz;
    vec3 param_6 = normal;
    float edgeScanVal = edgeScan(param_5, param_6);
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vec2(0.0);
    int uVertexShader = _230_vertexShader_IsAffectedByLight.x;
    bool _305 = uVertexShader == 0;
    #if (VERTEXSHADER == 0)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _332 = uVertexShader == 1;
    #if (VERTEXSHADER == 1)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    #endif
    bool _347 = uVertexShader == 2;
    #if (VERTEXSHADER == 2)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230_uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _379 = uVertexShader == 3;
    #if (VERTEXSHADER == 3)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    #endif
    bool _403 = uVertexShader == 4;
    #if (VERTEXSHADER == 4)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _427 = uVertexShader == 5;
    #if (VERTEXSHADER == 5)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = envCoord;
    #endif
    bool _444 = uVertexShader == 6;
    #if (VERTEXSHADER == 6)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _476 = uVertexShader == 7;
    #if (VERTEXSHADER == 7)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _507 = uVertexShader == 8;
    #if (VERTEXSHADER == 8)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord3 = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _546 = uVertexShader == 9;
    #if (VERTEXSHADER == 9)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _571 = uVertexShader == 10;
    #if (VERTEXSHADER == 10)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230_uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _594 = uVertexShader == 11;
    #if (VERTEXSHADER == 11)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230_uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _626 = uVertexShader == 12;
    #if (VERTEXSHADER == 12)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230_uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _659 = uVertexShader == 13;
    #if (VERTEXSHADER == 13)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = envCoord;
    #endif
    bool _677 = uVertexShader == 14;
    #if (VERTEXSHADER == 14)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230_uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _716 = uVertexShader == 15;
    #if (VERTEXSHADER == 15)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230_uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = vTexCoord3;
    #endif
    bool _748 = uVertexShader == 16;
    #if (VERTEXSHADER == 16)
    vec4 in_col0 = vec4(1.0);
    vDiffuseColor = vec4((in_col0.xyz * 0.5).x, (in_col0.xyz * 0.5).y, (in_col0.xyz * 0.5).z, in_col0.w);
    vTexCoord = (_230_uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vTexCoord3;
    #endif
    bool _780 = uVertexShader == 17;
    #if (VERTEXSHADER == 17)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _803 = uVertexShader == 18;
    #if (VERTEXSHADER == 18)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230_uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    gl_Position = _240_scene_uPMatrix * cameraPoint;
    vNormal = normal;
    vPosition = cameraPoint.xyz;
}


#version 100
precision mediump float;
precision highp int;

uniform float _34_gauss_offsets[5];
uniform float _34_gauss_weights[5];
uniform vec2 _34_uResolution;
uniform sampler2D u_sampler;
uniform sampler2D u_depth;

varying vec2 v_texcoord;

void main()
{
    float FXAA_SPAN_MAX = 8.0;
    float FXAA_REDUCE_MUL = 0.125;
    float FXAA_REDUCE_MIN = 0.0078125;
    vec3 rgbNW = texture2D(u_sampler, v_texcoord + (vec2(-1.0) / _34_uResolution)).xyz;
    vec3 rgbNE = texture2D(u_sampler, v_texcoord + (vec2(1.0, -1.0) / _34_uResolution)).xyz;
    vec3 rgbSW = texture2D(u_sampler, v_texcoord + (vec2(-1.0, 1.0) / _34_uResolution)).xyz;
    vec3 rgbSE = texture2D(u_sampler, v_texcoord + (vec2(1.0) / _34_uResolution)).xyz;
    vec3 rgbM = texture2D(u_sampler, v_texcoord).xyz;
    vec3 luma = vec3(0.2989999949932098388671875, 0.58700001239776611328125, 0.114000000059604644775390625);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM = dot(rgbM, luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y = (lumaNW + lumaSW) - (lumaNE + lumaSE);
    float dirReduce = max((((lumaNW + lumaNE) + lumaSW) + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) / _34_uResolution;
    vec3 rgbA = (texture2D(u_sampler, v_texcoord + (dir * (-0.16666667163372039794921875))).xyz + texture2D(u_sampler, v_texcoord + (dir * 0.16666667163372039794921875)).xyz) * 0.5;
    vec3 rgbB = (rgbA * 0.5) + ((texture2D(u_sampler, v_texcoord + (dir * (-0.5))).xyz + texture2D(u_sampler, v_texcoord + (dir * 0.5)).xyz) * 0.25);
    float lumaB = dot(rgbB, luma);
    bool _240 = (lumaB < lumaMin) || (lumaB > lumaMax);
    if (_240)
    {
        gl_FragData[0] = vec4(rgbA.x, rgbA.y, rgbA.z, gl_FragData[0].w);
    }
    else
    {
        gl_FragData[0] = vec4(rgbB.x, rgbB.y, rgbB.z, gl_FragData[0].w);
    }
}


#version 100
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

attribute vec4 a_position;
varying vec2 v_texcoord;

void main()
{
    gl_Position = a_position;
    v_texcoord = (a_position.xy * 0.5) + vec2(0.5);
}


#version 100
precision mediump float;
precision highp int;

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

uniform vec4 _256_uAlphaTestScalev;
uniform ivec4 _256_uPixelShaderv;
uniform vec4 _256_uTextureTranslate;
uniform mat4 _304_scene_uLookAtMat;
uniform mat4 _304_scene_uPMatrix;
uniform vec4 _304_scene_uViewUp;
uniform vec4 _304_scene_uInteriorSunDir;
uniform vec4 _304_scene_extLight_uExteriorAmbientColor;
uniform vec4 _304_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _304_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _304_scene_extLight_uExteriorDirectColor;
uniform vec4 _304_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _304_scene_extLight_adtSpecMult;
uniform vec4 _304_fogData_densityParams;
uniform vec4 _304_fogData_heightPlane;
uniform vec4 _304_fogData_color_and_heightRate;
uniform vec4 _304_fogData_heightDensity_and_endColor;
uniform vec4 _304_fogData_sunAngle_and_sunColor;
uniform vec4 _304_fogData_heightColor_and_endFogDistance;
uniform vec4 _304_fogData_sunPercentage;
uniform sampler2D uTexture;

varying vec2 vTexcoord0;
varying vec4 vColor;
varying vec3 vPosition;

vec3 validateFogColor(in vec3 fogColor, int blendMode) {
    return fogColor;
}
vec4 makeFog(PSFog fogData, vec4 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    float alpha = 1.0;
    bool _139 = blendMode == 13;
    if (_139)
    {
        alpha = min(finalFog, endFadeFog);
    }
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _218 = nDotSun > 0.0;
    if (_218)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final.xyz, vec3(min(finalFog, endFadeFog)));
    return vec4(fogFinal, final.w * alpha);
}

void main()
{
    vec2 textCoordScale = _256_uAlphaTestScalev.yz;
    vec2 texcoord = (vTexcoord0 * textCoordScale) + _256_uTextureTranslate.xy;
    vec4 tex = texture2D(uTexture, texcoord);
    vec4 finalColor = vec4(vColor.xyz * tex.xyz, tex.w * vColor.w);
    vec3 sunDir = _304_scene_extLight_uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _304_fogData_densityParams;
    arg.heightPlane = _304_fogData_heightPlane;
    arg.color_and_heightRate = _304_fogData_color_and_heightRate;
    arg.heightDensity_and_endColor = _304_fogData_heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _304_fogData_sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _304_fogData_heightColor_and_endFogDistance;
    arg.sunPercentage = _304_fogData_sunPercentage;
    vec4 param = finalColor;
    vec3 param_1 = vPosition;
    vec3 param_2 = sunDir;
    int param_3 = _256_uPixelShaderv.y;
    finalColor = makeFog(arg, param, param_1, param_2, param_3);
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

uniform mat4 _37_scene_uLookAtMat;
uniform mat4 _37_scene_uPMatrix;
uniform vec4 _37_scene_uViewUp;
uniform vec4 _37_scene_uInteriorSunDir;
uniform vec4 _37_scene_extLight_uExteriorAmbientColor;
uniform vec4 _37_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _37_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _37_scene_extLight_uExteriorDirectColor;
uniform vec4 _37_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _37_scene_extLight_adtSpecMult;
uniform vec4 _37_fogData_densityParams;
uniform vec4 _37_fogData_heightPlane;
uniform vec4 _37_fogData_color_and_heightRate;
uniform vec4 _37_fogData_heightDensity_and_endColor;
uniform vec4 _37_fogData_sunAngle_and_sunColor;
uniform vec4 _37_fogData_heightColor_and_endFogDistance;
uniform vec4 _37_fogData_sunPercentage;
attribute vec3 aPosition;
varying vec4 vColor;
attribute vec4 aColor;
varying vec2 vTexcoord0;
attribute vec2 aTexcoord0;
varying vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vec4 vertexViewSpace = _37_scene_uLookAtMat * aPositionVec4;
    vPosition = vertexViewSpace.xyz;
    gl_Position = _37_scene_uPMatrix * vertexViewSpace;
}


#version 100
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif
precision mediump float;
precision highp int;

varying vec4 vColor;

void main()
{
    gl_FragData[0] = vec4(vColor.xyz, vColor.w);
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

uniform mat4 _26_scene_uLookAtMat;
uniform mat4 _26_scene_uPMatrix;
uniform vec4 _26_scene_uViewUp;
uniform vec4 _26_scene_uInteriorSunDir;
uniform vec4 _26_scene_extLight_uExteriorAmbientColor;
uniform vec4 _26_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _26_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _26_scene_extLight_uExteriorDirectColor;
uniform vec4 _26_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _26_scene_extLight_adtSpecMult;
uniform vec4 _26_fogData_densityParams;
uniform vec4 _26_fogData_heightPlane;
uniform vec4 _26_fogData_color_and_heightRate;
uniform vec4 _26_fogData_heightDensity_and_endColor;
uniform vec4 _26_fogData_sunAngle_and_sunColor;
uniform vec4 _26_fogData_heightColor_and_endFogDistance;
uniform vec4 _26_fogData_sunPercentage;
uniform vec4 _67_skyColor[6];
attribute vec4 aPosition;
varying vec4 vColor;

void main()
{
    vec3 inputPos = aPosition.xyz;
    inputPos *= 33.33300018310546875;
    vec4 cameraPos = _26_scene_uLookAtMat * vec4(inputPos, 1.0);
    vec3 _46 = cameraPos.xyz - _26_scene_uLookAtMat[3].xyz;
    cameraPos = vec4(_46.x, _46.y, _46.z, cameraPos.w);
    cameraPos.z = cameraPos.z;
    vec4 vertPosInNDC = _26_scene_uPMatrix * cameraPos;
    vColor = _67_skyColor[int(aPosition.w)];
    gl_Position = _26_scene_uPMatrix * cameraPos;
}


#version 100
precision mediump float;
precision highp int;

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

uniform vec4 _253_color;
uniform mat4 _277_scene_uLookAtMat;
uniform mat4 _277_scene_uPMatrix;
uniform vec4 _277_scene_uViewUp;
uniform vec4 _277_scene_uInteriorSunDir;
uniform vec4 _277_scene_extLight_uExteriorAmbientColor;
uniform vec4 _277_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _277_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _277_scene_extLight_uExteriorDirectColor;
uniform vec4 _277_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _277_scene_extLight_adtSpecMult;
uniform vec4 _277_fogData_densityParams;
uniform vec4 _277_fogData_heightPlane;
uniform vec4 _277_fogData_color_and_heightRate;
uniform vec4 _277_fogData_heightDensity_and_endColor;
uniform vec4 _277_fogData_sunAngle_and_sunColor;
uniform vec4 _277_fogData_heightColor_and_endFogDistance;
uniform vec4 _277_fogData_sunPercentage;
uniform sampler2D uTexture;

varying vec2 vTextCoords;
varying vec3 vPosition;

vec3 validateFogColor(in vec3 fogColor, int blendMode) {
    return fogColor;
}
vec4 makeFog(PSFog fogData, vec4 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    float alpha = 1.0;
    bool _139 = blendMode == 13;
    if (_139)
    {
        alpha = min(finalFog, endFadeFog);
    }
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _218 = nDotSun > 0.0;
    if (_218)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final.xyz, vec3(min(finalFog, endFadeFog)));
    return vec4(fogFinal, final.w * alpha);
}

void main()
{
    vec3 finalColor = _253_color.xyz + texture2D(uTexture, vTextCoords).xyz;
    vec3 sunDir = _277_scene_extLight_uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _277_fogData_densityParams;
    arg.heightPlane = _277_fogData_heightPlane;
    arg.color_and_heightRate = _277_fogData_color_and_heightRate;
    arg.heightDensity_and_endColor = _277_fogData_heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _277_fogData_sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _277_fogData_heightColor_and_endFogDistance;
    arg.sunPercentage = _277_fogData_sunPercentage;
    vec4 param = vec4(finalColor, 1.0);
    vec3 param_1 = vPosition;
    vec3 param_2 = sunDir;
    int param_3 = 2;
    finalColor = makeFog(arg, param, param_1, param_2, param_3).xyz;
    gl_FragData[0] = vec4(finalColor, 0.699999988079071044921875);
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

uniform mat4 _28_scene_uLookAtMat;
uniform mat4 _28_scene_uPMatrix;
uniform vec4 _28_scene_uViewUp;
uniform vec4 _28_scene_uInteriorSunDir;
uniform vec4 _28_scene_extLight_uExteriorAmbientColor;
uniform vec4 _28_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _28_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _28_scene_extLight_uExteriorDirectColor;
uniform vec4 _28_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _28_scene_extLight_adtSpecMult;
uniform vec4 _28_fogData_densityParams;
uniform vec4 _28_fogData_heightPlane;
uniform vec4 _28_fogData_color_and_heightRate;
uniform vec4 _28_fogData_heightDensity_and_endColor;
uniform vec4 _28_fogData_sunAngle_and_sunColor;
uniform vec4 _28_fogData_heightColor_and_endFogDistance;
uniform vec4 _28_fogData_sunPercentage;
uniform mat4 _36_uPlacementMat;
attribute vec4 aPositionTransp;
varying vec2 vTextCoords;
varying vec3 vPosition;
attribute vec2 aTexCoord;

void main()
{
    vec4 aPositionVec4 = vec4(aPositionTransp.xyz, 1.0);
    mat4 cameraMatrix = _28_scene_uLookAtMat * _36_uPlacementMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    vTextCoords = aPositionVec4.xy * 0.02999999932944774627685546875;
    gl_Position = _28_scene_uPMatrix * cameraPoint;
    vPosition = cameraPoint.xyz;
}


#version 100
precision mediump float;
precision highp int;

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

uniform vec4 _445_values0;
uniform vec4 _445_values1;
uniform vec4 _445_values2;
uniform vec4 _445_values3;
uniform vec4 _445_values4;
uniform vec4 _445_baseColor;
uniform mat4 _709_scene_uLookAtMat;
uniform mat4 _709_scene_uPMatrix;
uniform vec4 _709_scene_uViewUp;
uniform vec4 _709_scene_uInteriorSunDir;
uniform vec4 _709_scene_extLight_uExteriorAmbientColor;
uniform vec4 _709_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _709_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _709_scene_extLight_uExteriorDirectColor;
uniform vec4 _709_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _709_scene_extLight_adtSpecMult;
uniform vec4 _709_fogData_densityParams;
uniform vec4 _709_fogData_heightPlane;
uniform vec4 _709_fogData_color_and_heightRate;
uniform vec4 _709_fogData_heightDensity_and_endColor;
uniform vec4 _709_fogData_sunAngle_and_sunColor;
uniform vec4 _709_fogData_heightColor_and_endFogDistance;
uniform vec4 _709_fogData_sunPercentage;
uniform mat4 _818_uPlacementMat;
uniform mat4 _818_uBoneMatrixes[220];
uniform sampler2D uNormalTex;
uniform sampler2D uNoise;
uniform sampler2D uWhiteWater;
uniform sampler2D uMask;

varying vec2 vTexCoord2_animated;
varying vec3 vPosition;
varying vec3 vNormal;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;

vec3 PerturbNormal(vec3 surf_pos, vec3 surf_norm)
{
    vec2 dBdUV = ((texture2D(uNormalTex, vTexCoord2_animated).xy * 2.0) - vec2(1.0)) * (_445_values3.x * 100.0);
    vec2 duv1 = dFdx(vTexCoord2_animated);
    vec2 duv2 = dFdy(vTexCoord2_animated);
    vec3 vSigmaS = dFdx(surf_pos);
    vec3 vSigmaT = dFdy(surf_pos);
    vec3 vN = surf_norm;
    vec3 vR1 = cross(vSigmaT, vN);
    vec3 vR2 = cross(vN, vSigmaS);
    float fDet = dot(vSigmaS, vR1);
    float dBs = (dBdUV.x * duv1.x) + (dBdUV.y * duv1.y);
    float dBt = (dBdUV.x * duv2.x) + (dBdUV.y * duv2.y);
    vec3 vSurfGrad = ((vR1 * dBs) + (vR2 * dBt)) * sign(fDet);
    return normalize((vN * abs(fDet)) - vSurfGrad);
}

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular, vec3 emissive)
{
    vec3 localDiffuse = accumLight;
    bool _57 = !applyLight;
    if (_57)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _73 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_73)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _110 = nDotUp >= 0.0;
        if (_110)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _150 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_150)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _174 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_174)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = emissive;
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 validateFogColor(in vec3 fogColor, int blendMode) {
    return fogColor;
}
vec4 makeFog(PSFog fogData, vec4 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    float alpha = 1.0;
    bool _316 = blendMode == 13;
    if (_316)
    {
        alpha = min(finalFog, endFadeFog);
    }
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _394 = nDotSun > 0.0;
    if (_394)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final.xyz, vec3(min(finalFog, endFadeFog)));
    return vec4(fogFinal, final.w * alpha);
}

void main()
{
    vec3 param = vPosition;
    vec3 param_1 = normalize(vNormal);
    vec3 perturbedNormal = PerturbNormal(param, param_1);
    vec2 vTexCoordNorm = vTexCoord / vec2(_445_values1.x);
    float noise0 = texture2D(uNoise, vec2(vTexCoordNorm.x - _445_values1.z, (vTexCoordNorm.y - _445_values1.z) - _445_values2.z)).x;
    float _noise1 = texture2D(uNoise, vec2((vTexCoordNorm.x - _445_values1.z) + 0.4180000126361846923828125, ((vTexCoordNorm.y + 0.3549999892711639404296875) + _445_values1.z) - _445_values2.z)).x;
    float _noise2 = texture2D(uNoise, vec2((vTexCoordNorm.x + _445_values1.z) + 0.8650000095367431640625, ((vTexCoordNorm.y + 0.1480000019073486328125) - _445_values1.z) - _445_values2.z)).x;
    float _noise3 = texture2D(uNoise, vec2((vTexCoordNorm.x + _445_values1.z) + 0.65100002288818359375, ((vTexCoordNorm.y + 0.75199997425079345703125) + _445_values1.z) - _445_values2.z)).x;
    float noise_avr = abs(((noise0 + _noise1) + _noise2) + _noise3) * 0.25;
    float noiseFinal = clamp(exp((_445_values0.x * log2(noise_avr)) * 2.2000000476837158203125) * _445_values0.y, 0.0, 1.0);
    vec4 whiteWater_val = texture2D(uWhiteWater, vTexCoord2_animated);
    vec4 mask_val_0 = texture2D(uMask, vTexCoord);
    vec4 mask_val_1 = texture2D(uMask, vec2(vTexCoord.x, vTexCoord.y + _445_values3.z));
    float mix_alpha = clamp((((((whiteWater_val.w * noiseFinal) - (mask_val_1.y * mask_val_0.x)) * 2.0) + _445_values0.z) * ((_445_values0.w * 2.0) + 1.0)) - _445_values0.w, 0.0, 1.0);
    vec4 whiteWater_val_baseColor_mix = mix(_445_baseColor, whiteWater_val, vec4(mix_alpha));
    vec3 param_2 = whiteWater_val_baseColor_mix.xyz;
    vec3 param_3 = perturbedNormal;
    bool param_4 = true;
    float param_5 = 0.0;
    SceneWideParams param_6;
    param_6.uLookAtMat = _709_scene_uLookAtMat;
    param_6.uPMatrix = _709_scene_uPMatrix;
    param_6.uViewUp = _709_scene_uViewUp;
    param_6.uInteriorSunDir = _709_scene_uInteriorSunDir;
    param_6.extLight.uExteriorAmbientColor = _709_scene_extLight_uExteriorAmbientColor;
    param_6.extLight.uExteriorHorizontAmbientColor = _709_scene_extLight_uExteriorHorizontAmbientColor;
    param_6.extLight.uExteriorGroundAmbientColor = _709_scene_extLight_uExteriorGroundAmbientColor;
    param_6.extLight.uExteriorDirectColor = _709_scene_extLight_uExteriorDirectColor;
    param_6.extLight.uExteriorDirectColorDir = _709_scene_extLight_uExteriorDirectColorDir;
    param_6.extLight.adtSpecMult = _709_scene_extLight_adtSpecMult;
    InteriorLightParam param_7 = InteriorLightParam(vec4(0.0), vec4(0.0, 0.0, 0.0, 1.0));
    vec3 param_8 = vec3(0.0);
    vec3 colorAfterLight = calcLight(param_2, param_3, param_4, param_5, param_6, param_7, param_8, vec3(0.0), vec3(0.0), vec3(0.0));
    float w_clamped = clamp((1.0 - mask_val_0.w) * _445_values1.w, 0.0, 1.0);
    float w_alpha_combined = clamp(w_clamped + mix_alpha, 0.0, 1.0);
    vec4 finalColor = vec4(mix(colorAfterLight, whiteWater_val_baseColor_mix.xyz, vec3(_445_values3.w)), w_alpha_combined);
    vec3 sunDir = _709_scene_extLight_uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _709_fogData_densityParams;
    arg.heightPlane = _709_fogData_heightPlane;
    arg.color_and_heightRate = _709_fogData_color_and_heightRate;
    arg.heightDensity_and_endColor = _709_fogData_heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _709_fogData_sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _709_fogData_heightColor_and_endFogDistance;
    arg.sunPercentage = _709_fogData_sunPercentage;
    vec4 param_9 = finalColor;
    vec3 param_10 = vPosition;
    vec3 param_11 = sunDir;
    int param_12 = 0;
    finalColor = makeFog(arg, param_9, param_10, param_11, param_12);
    gl_FragData[0] = finalColor;
}


#version 100
#extension GL_ARB_shader_texture_lod : require

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

uniform vec4 _55_bumpScale;
uniform mat4 _55_uTextMat[2];
uniform mat4 _104_uPlacementMat;
uniform mat4 _104_uBoneMatrixes[220];
uniform mat4 _199_scene_uLookAtMat;
uniform mat4 _199_scene_uPMatrix;
uniform vec4 _199_scene_uViewUp;
uniform vec4 _199_scene_uInteriorSunDir;
uniform vec4 _199_scene_extLight_uExteriorAmbientColor;
uniform vec4 _199_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _199_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _199_scene_extLight_uExteriorDirectColor;
uniform vec4 _199_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _199_scene_extLight_adtSpecMult;
uniform vec4 _199_fogData_densityParams;
uniform vec4 _199_fogData_heightPlane;
uniform vec4 _199_fogData_color_and_heightRate;
uniform vec4 _199_fogData_heightDensity_and_endColor;
uniform vec4 _199_fogData_sunAngle_and_sunColor;
uniform vec4 _199_fogData_heightColor_and_endFogDistance;
uniform vec4 _199_fogData_sunPercentage;
uniform sampler2D uBumpTexture;

attribute vec2 aTexCoord2;
attribute vec3 aNormal;
attribute vec3 aPosition;
attribute vec4 boneWeights;
attribute vec4 bones;
varying vec3 vNormal;
varying vec3 vPosition;
varying vec2 vTexCoord;
attribute vec2 aTexCoord;
varying vec2 vTexCoord2_animated;
varying vec2 vTexCoord2;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

void main()
{
    vec2 texCoord2 = (_55_uTextMat[0] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vec4 bumpValue = texture2DLod(uBumpTexture, texCoord2, 0.0);
    vec3 pos = ((aNormal * _55_bumpScale.x) * bumpValue.z) + aPosition;
    mat4 boneTransformMat = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0));
    mat4 _113 = _104_uBoneMatrixes[bones.x] * boneWeights.x;
    boneTransformMat = mat4(boneTransformMat[0] + _113[0], boneTransformMat[1] + _113[1], boneTransformMat[2] + _113[2], boneTransformMat[3] + _113[3]);
    mat4 _135 = _104_uBoneMatrixes[bones.y] * boneWeights.y;
    boneTransformMat = mat4(boneTransformMat[0] + _135[0], boneTransformMat[1] + _135[1], boneTransformMat[2] + _135[2], boneTransformMat[3] + _135[3]);
    mat4 _156 = _104_uBoneMatrixes[bones.z] * boneWeights.z;
    boneTransformMat = mat4(boneTransformMat[0] + _156[0], boneTransformMat[1] + _156[1], boneTransformMat[2] + _156[2], boneTransformMat[3] + _156[3]);
    mat4 _178 = _104_uBoneMatrixes[bones.w] * boneWeights.w;
    boneTransformMat = mat4(boneTransformMat[0] + _178[0], boneTransformMat[1] + _178[1], boneTransformMat[2] + _178[2], boneTransformMat[3] + _178[3]);
    mat4 cameraMatrix = (_199_scene_uLookAtMat * _104_uPlacementMat) * boneTransformMat;
    vec4 cameraPoint = cameraMatrix * vec4(pos, 1.0);
    mat4 param = _199_scene_uLookAtMat;
    mat4 param_1 = _104_uPlacementMat;
    mat4 param_2 = boneTransformMat;
    mat3 viewModelMatTransposed = (blizzTranspose(param) * blizzTranspose(param_1)) * blizzTranspose(param_2);
    vNormal = ((_199_scene_uLookAtMat * _104_uPlacementMat) * vec4(aNormal, 0.0)).xyz;
    vPosition = pos;
    vTexCoord = aTexCoord;
    vTexCoord2_animated = texCoord2;
    vTexCoord2 = aTexCoord2;
    gl_Position = _199_scene_uPMatrix * cameraPoint;
}


#version 100
precision mediump float;
precision highp int;

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

uniform vec4 _525_intLight_uInteriorAmbientColorAndApplyInteriorLight;
uniform vec4 _525_intLight_uInteriorDirectColorAndApplyExteriorLight;
uniform mat4 _537_scene_uLookAtMat;
uniform mat4 _537_scene_uPMatrix;
uniform vec4 _537_scene_uViewUp;
uniform vec4 _537_scene_uInteriorSunDir;
uniform vec4 _537_scene_extLight_uExteriorAmbientColor;
uniform vec4 _537_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _537_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _537_scene_extLight_uExteriorDirectColor;
uniform vec4 _537_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _537_scene_extLight_adtSpecMult;
uniform vec4 _537_fogData_densityParams;
uniform vec4 _537_fogData_heightPlane;
uniform vec4 _537_fogData_color_and_heightRate;
uniform vec4 _537_fogData_heightDensity_and_endColor;
uniform vec4 _537_fogData_sunAngle_and_sunColor;
uniform vec4 _537_fogData_heightColor_and_endFogDistance;
uniform vec4 _537_fogData_sunPercentage;
uniform ivec4 _657_UseLitColor_EnableAlpha_PixelShader_BlendMode;
uniform vec4 _657_FogColor_AlphaTest;
uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;
uniform sampler2D uTexture6;
uniform sampler2D uTexture4;
uniform sampler2D uTexture5;
uniform sampler2D uTexture7;
uniform sampler2D uTexture8;
uniform sampler2D uTexture9;

varying vec3 vNormal;
varying vec4 vColor;
varying vec4 vPosition;
varying vec2 vTexCoord;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vColor2;
varying vec4 vColorSecond;
varying vec2 vTexCoord4;

vec3 Slerp(vec3 p0, vec3 p1, float t)
{
    float dotp = dot(normalize(p0), normalize(p1));
    bool _479 = (dotp > 0.99989998340606689453125) || (dotp < (-0.99989998340606689453125));
    if (_479)
    {
        bool _483 = t <= 0.5;
        if (_483)
        {
            return p0;
        }
        return p1;
    }
    float theta = acos(dotp);
    vec3 P = ((p0 * sin((1.0 - t) * theta)) + (p1 * sin(t * theta))) / vec3(sin(theta));
    return P;
}

vec3 calcSpec(float texAlpha)
{
    vec3 normal = normalize(vNormal);
    vec3 sunDir = vec3(0.0);
    vec3 sunColor = vec3(0.0);
    bool _529 = _525_intLight_uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    if (_529)
    {
        sunDir = -_537_scene_extLight_uExteriorDirectColorDir.xyz;
        sunColor = _537_scene_extLight_uExteriorDirectColor.xyz;
    }
    bool _548 = _525_intLight_uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_548)
    {
        sunDir = -_537_scene_uInteriorSunDir.xyz;
        sunColor = _525_intLight_uInteriorDirectColorAndApplyExteriorLight.xyz;
        bool _560 = _525_intLight_uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_560)
        {
            vec3 param = sunDir;
            vec3 param_1 = -_537_scene_extLight_uExteriorDirectColorDir.xyz;
            float param_2 = vColor.w;
            sunDir = Slerp(param, param_1, param_2);
            sunColor = mix(sunColor, _537_scene_extLight_uExteriorDirectColor.xyz, vec3(vColor.w));
        }
    }
    vec3 t849 = normalize(sunDir + normalize(-vPosition.xyz));
    float dirAtten_956 = clamp(dot(normal, sunDir), 0.0, 1.0);
    float spec = 1.25 * pow(clamp(dot(normal, t849), 0.0, 1.0), 8.0);
    vec3 specTerm = ((vec3(mix(pow(1.0 - clamp(dot(sunDir, t849), 0.0, 1.0), 5.0), 1.0, texAlpha)) * spec) * sunColor) * dirAtten_956;
    float distFade = 1.0;
    specTerm *= distFade;
    return specTerm;
}

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight, vec3 specular, vec3 emissive)
{
    vec3 localDiffuse = accumLight;
    bool _68 = !applyLight;
    if (_68)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    bool _84 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    vec3 currColor;
    if (_84)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _121 = nDotUp >= 0.0;
        if (_121)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _161 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_161)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _185 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_185)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = specular;
    vec3 emTerm = emissive;
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

vec3 validateFogColor(in vec3 fogColor, int blendMode) {
    return fogColor;
}
vec4 makeFog(PSFog fogData, vec4 final, vec3 vertexInViewSpace, vec3 sunDirInViewSpace, int blendMode)
{
    vec4 l_densityParams = fogData.densityParams;
    vec4 l_heightPlane = fogData.heightPlane;
    vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    float start = l_densityParams.x;
    float end = l_densityParams.y;
    float density = l_densityParams.z;
    float bias = l_densityParams.w;
    float vLength = length(vertexInViewSpace);
    float z = vLength - bias;
    float expMax = max(0.0, z - start);
    float expFog = 1.0 / exp(expMax * density);
    float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    float finalFog = mix(expFog, expFogHeight, heightFog);
    float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    float alpha = 1.0;
    bool _327 = blendMode == 13;
    if (_327)
    {
        alpha = min(finalFog, endFadeFog);
    }
    vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    vec3 endColor = validateFogColor(param, param_1);
    vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    float end2 = vLength / l_heightColor_and_endFogDistance.w;
    float end2_cube = end2 * (end2 * end2);
    vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _405 = nDotSun > 0.0;
    if (_405)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final.xyz, vec3(min(finalFog, endFadeFog)));
    return vec4(fogFinal, final.w * alpha);
}

void main()
{
    vec4 tex = texture2D(uTexture, vTexCoord);
    vec4 tex2 = texture2D(uTexture2, vTexCoord2);
    vec4 tex3 = texture2D(uTexture3, vTexCoord3);
    bool _661 = _657_UseLitColor_EnableAlpha_PixelShader_BlendMode.y == 1;
    if (_661)
    {
        bool _668 = (tex.w - 0.501960813999176025390625) < 0.0;
        if (_668)
        {
            discard;
        }
    }
    int uPixelShader = _657_UseLitColor_EnableAlpha_PixelShader_BlendMode.z;
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 matDiffuse = vec3(0.0);
    vec3 spec = vec3(0.0);
    vec3 emissive = vec3(0.0);
    float finalOpacity = 0.0;
    float distFade = 1.0;
    bool _684 = uPixelShader == (-1);
    #if (FRAGMENTSHADER == (-1))
    matDiffuse = tex.xyz * tex2.xyz;
    finalOpacity = tex.w;
    #endif
    bool _696 = uPixelShader == 0;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = tex.xyz;
    finalOpacity = tex.w;
    #endif
    bool _705 = uPixelShader == 1;
    #if (FRAGMENTSHADER == 1)
    matDiffuse = tex.xyz;
    float param = tex.w;
    spec = calcSpec(param);
    finalOpacity = tex.w;
    #endif
    bool _718 = uPixelShader == 2;
    #if (FRAGMENTSHADER == 2)
    matDiffuse = tex.xyz;
    float param_1 = ((tex * 4.0) * tex.w).x;
    spec = calcSpec(param_1);
    finalOpacity = tex.w;
    #endif
    bool _736 = uPixelShader == 3;
    #if (FRAGMENTSHADER == 3)
    matDiffuse = tex.xyz;
    emissive = (tex2.xyz * tex.w) * distFade;
    finalOpacity = 1.0;
    #endif
    bool _750 = uPixelShader == 4;
    #if (FRAGMENTSHADER == 4)
    matDiffuse = tex.xyz;
    finalOpacity = 1.0;
    #endif
    bool _757 = uPixelShader == 5;
    #if (FRAGMENTSHADER == 5)
    matDiffuse = tex.xyz;
    emissive = ((tex.xyz * tex.w) * tex2.xyz) * distFade;
    finalOpacity = 1.0;
    #endif
    bool _774 = uPixelShader == 6;
    #if (FRAGMENTSHADER == 6)
    vec3 layer1 = tex.xyz;
    vec3 layer2 = mix(layer1, tex2.xyz, vec3(tex2.w));
    matDiffuse = mix(layer2, layer1, vec3(vColor2.w));
    finalOpacity = tex.w;
    #endif
    bool _800 = uPixelShader == 7;
    #if (FRAGMENTSHADER == 7)
    vec4 colorMix = mix(tex2, tex, vec4(vColor2.w));
    matDiffuse = colorMix.xyz;
    emissive = ((colorMix.xyz * colorMix.w) * tex3.xyz) * distFade;
    finalOpacity = tex.w;
    #endif
    bool _827 = uPixelShader == 8;
    #if (FRAGMENTSHADER == 8)
    vec3 layer1_1 = tex.xyz;
    vec3 layer2_1 = tex2.xyz;
    matDiffuse = mix(layer2_1, layer1_1, vec3(vColor2.w));
    float param_2 = tex2.w * (1.0 - vColor2.w);
    spec = calcSpec(param_2);
    finalOpacity = tex.w;
    #endif
    bool _855 = uPixelShader == 9;
    #if (FRAGMENTSHADER == 9)
    matDiffuse = tex.xyz;
    emissive = (tex2.xyz * tex2.w) * vColor2.w;
    finalOpacity = tex.w;
    #endif
    bool _873 = uPixelShader == 10;
    #if (FRAGMENTSHADER == 10)
    float mixFactor = clamp(tex3.w * vColor2.w, 0.0, 1.0);
    matDiffuse = mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(mixFactor)), tex.xyz, vec3(tex.w));
    finalOpacity = tex.w;
    #endif
    bool _905 = uPixelShader == 11;
    #if (FRAGMENTSHADER == 11)
    matDiffuse = tex.xyz;
    emissive = ((tex.xyz * tex.w) * tex2.xyz) + ((tex3.xyz * tex3.w) * vColor2.w);
    finalOpacity = tex.w;
    #endif
    bool _932 = uPixelShader == 12;
    #if (FRAGMENTSHADER == 12)
    matDiffuse = mix(tex2.xyz, tex.xyz, vec3(vColor2.w));
    finalOpacity = 1.0;
    #endif
    bool _945 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    vec3 t1diffuse = tex2.xyz * (1.0 - tex2.w);
    matDiffuse = mix(t1diffuse, tex.xyz, vec3(vColor2.w));
    emissive = (tex2.xyz * tex2.w) * (1.0 - vColor2.w);
    finalOpacity = tex.w;
    #endif
    bool _976 = uPixelShader == 14;
    #if (FRAGMENTSHADER == 14)
    matDiffuse = mix(((tex.xyz * tex2.xyz) * 2.0) + (tex3.xyz * clamp(tex3.w * vColor2.w, 0.0, 1.0)), tex.xyz, vec3(tex.w));
    finalOpacity = 1.0;
    #endif
    bool _1004 = uPixelShader == 15;
    #if (FRAGMENTSHADER == 15)
    vec3 layer1_2 = tex.xyz;
    vec3 layer2_2 = mix(layer1_2, tex2.xzy, vec3(tex2.w));
    vec3 layer3 = mix(layer2_2, layer1_2, vec3(vColor2.w));
    matDiffuse = (layer3 * tex3.xyz) * 2.0;
    finalOpacity = tex.w;
    #endif
    bool _1034 = uPixelShader == 16;
    #if (FRAGMENTSHADER == 16)
    vec3 layer1_3 = (tex.xyz * tex2.xyz) * 2.0;
    matDiffuse = mix(tex.xyz, layer1_3, vec3(vColor2.w));
    finalOpacity = tex.w;
    #endif
    bool _1055 = uPixelShader == 17;
    #if (FRAGMENTSHADER == 17)
    vec3 layer1_4 = tex.xyz;
    vec3 layer2_3 = mix(layer1_4, tex2.xyz, vec3(tex2.w));
    vec3 layer3_1 = mix(layer2_3, layer1_4, vec3(tex3.w));
    matDiffuse = (layer3_1 * tex3.xyz) * 2.0;
    finalOpacity = tex.w;
    #endif
    bool _1085 = uPixelShader == 18;
    #if (FRAGMENTSHADER == 18)
    matDiffuse = tex.xyz;
    finalOpacity = tex.w;
    #endif
    bool _1094 = uPixelShader == 19;
    #if (FRAGMENTSHADER == 19)
    vec4 tex_6 = texture2D(uTexture6, vTexCoord2);
    vec3 crossDy = cross(dFdy(vPosition.xyz), vNormal);
    vec3 crossDx = cross(vNormal, dFdx(vPosition.xyz));
    vec2 dTexCoord2Dx = dFdx(vTexCoord2);
    vec2 dTexCoord2Dy = dFdy(vTexCoord2);
    vec3 sum1 = (crossDx * dTexCoord2Dy.x) + (crossDy * dTexCoord2Dx.x);
    vec3 sum2 = (crossDx * dTexCoord2Dy.y) + (crossDy * dTexCoord2Dx.y);
    float maxInverseDot = inversesqrt(max(dot(sum1, sum1), dot(sum2, sum2)));
    float cosAlpha = dot(normalize(vPosition.xyz), vNormal);
    float dot1 = dot(sum1 * maxInverseDot, normalize(vPosition.xyz)) / cosAlpha;
    float dot2 = dot(sum2 * maxInverseDot, normalize(vPosition.xyz)) / cosAlpha;
    vec4 tex_4 = texture2D(uTexture4, vTexCoord2 - ((vec2(dot1, dot2) * tex_6.x) * 0.25));
    vec4 tex_5 = texture2D(uTexture5, vTexCoord3 - ((vec2(dot1, dot2) * tex_6.x) * 0.25));
    vec4 tex_3 = texture2D(uTexture3, vTexCoord2);
    vec3 mix1 = tex_5.xyz + (tex_4.xyz * tex_4.w);
    vec3 mix2 = ((tex_3.xyz - mix1) * tex_6.y) + mix1;
    vec3 mix3 = (tex_3.xyz * tex_6.z) + ((tex_5.xyz * tex_5.w) * (1.0 - tex3.z));
    vec4 tex_2 = texture2D(uTexture3, vColorSecond.zy);
    vec3 tex_2_mult = tex_2.xyz * tex_2.w;
    bool _1256 = vColor2.w > 0.0;
    vec3 emissive_component;
    if (_1256)
    {
        vec4 tex_1 = texture2D(uTexture, vTexCoord);
        matDiffuse = ((tex_1.xyz - mix2) * vColor2.w) + mix2;
        emissive_component = (((tex_1.xyz * tex_1.w) - tex_2_mult) * vColor2.w) + tex_2_mult;
    }
    else
    {
        emissive_component = tex_2_mult;
        matDiffuse = mix2;
    }
    emissive = (mix3 - (mix3 * vColor2.w)) + (emissive_component * tex_2.xyz);
    #endif
    bool _1301 = uPixelShader == 20;
    #if (FRAGMENTSHADER == 20)
    vec3 param_3 = vPosition.xyz;
    vec3 param_4 = vNormal;
    vec4 tex_1_1 = texture2D(uTexture, posToTexCoord(param_3, param_4));
    vec4 tex_2_1 = texture2D(uTexture2, vTexCoord);
    vec4 tex_3_1 = texture2D(uTexture3, vTexCoord2);
    vec4 tex_4_1 = texture2D(uTexture4, vTexCoord3);
    vec4 tex_5_1 = texture2D(uTexture5, vTexCoord4);
    vec4 tex_6_1 = texture2D(uTexture6, vTexCoord);
    vec4 tex_7 = texture2D(uTexture7, vTexCoord2);
    vec4 tex_8 = texture2D(uTexture8, vTexCoord3);
    vec4 tex_9 = texture2D(uTexture9, vTexCoord4);
    float secondColorSum = dot(vColorSecond.zyx, vec3(1.0));
    vec4 alphaVec = max(vec4(tex_6_1.w, tex_7.w, tex_8.w, tex_9.w), vec4(0.0040000001899898052215576171875)) * vec4(vColorSecond.zyx, 1.0 - clamp(secondColorSum, 0.0, 1.0));
    float maxAlpha = max(alphaVec.x, max(alphaVec.y, max(alphaVec.x, alphaVec.w)));
    vec4 alphaVec2 = vec4(1.0) - clamp(vec4(maxAlpha) - alphaVec, vec4(0.0), vec4(1.0));
    alphaVec2 *= alphaVec;
    vec4 alphaVec2Normalized = alphaVec2 * (1.0 / dot(alphaVec2, vec4(1.0)));
    vec4 texMixed = (((tex_2_1 * alphaVec2Normalized.x) + (tex_3_1 * alphaVec2Normalized.y)) + (tex_4_1 * alphaVec2Normalized.z)) + (tex_5_1 * alphaVec2Normalized.w);
    emissive = (tex_1_1.xyz * texMixed.w) * texMixed.xyz;
    vec3 diffuseColor = vec3(0.0);
    matDiffuse = ((diffuseColor - texMixed.xyz) * vColorSecond.w) + texMixed.xyz;
    #endif
    vec3 param_5 = matDiffuse;
    vec3 param_6 = vNormal;
    bool param_7 = true;
    float param_8 = vColor.w;
    SceneWideParams param_9;
    param_9.uLookAtMat = _537_scene_uLookAtMat;
    param_9.uPMatrix = _537_scene_uPMatrix;
    param_9.uViewUp = _537_scene_uViewUp;
    param_9.uInteriorSunDir = _537_scene_uInteriorSunDir;
    param_9.extLight.uExteriorAmbientColor = _537_scene_extLight_uExteriorAmbientColor;
    param_9.extLight.uExteriorHorizontAmbientColor = _537_scene_extLight_uExteriorHorizontAmbientColor;
    param_9.extLight.uExteriorGroundAmbientColor = _537_scene_extLight_uExteriorGroundAmbientColor;
    param_9.extLight.uExteriorDirectColor = _537_scene_extLight_uExteriorDirectColor;
    param_9.extLight.uExteriorDirectColorDir = _537_scene_extLight_uExteriorDirectColorDir;
    param_9.extLight.adtSpecMult = _537_scene_extLight_adtSpecMult;
    InteriorLightParam param_10;
    param_10.uInteriorAmbientColorAndApplyInteriorLight = _525_intLight_uInteriorAmbientColorAndApplyInteriorLight;
    param_10.uInteriorDirectColorAndApplyExteriorLight = _525_intLight_uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_11 = vec3(0.0);
    finalColor = vec4(calcLight(param_5, param_6, param_7, param_8, param_9, param_10, param_11, vColor.xyz, spec, emissive), finalOpacity);
    PSFog arg;
    arg.densityParams = _537_fogData_densityParams;
    arg.heightPlane = _537_fogData_heightPlane;
    arg.color_and_heightRate = _537_fogData_color_and_heightRate;
    arg.heightDensity_and_endColor = _537_fogData_heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _537_fogData_sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _537_fogData_heightColor_and_endFogDistance;
    arg.sunPercentage = _537_fogData_sunPercentage;
    vec4 param_12 = finalColor;
    vec3 param_13 = vPosition.xyz;
    vec3 param_14 = _537_scene_extLight_uExteriorDirectColorDir.xyz;
    int param_15 = _657_UseLitColor_EnableAlpha_PixelShader_BlendMode.w;
    finalColor = makeFog(arg, param_12, param_13, param_14, param_15);
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

uniform mat4 _93_uPlacementMat;
uniform mat4 _111_scene_uLookAtMat;
uniform mat4 _111_scene_uPMatrix;
uniform vec4 _111_scene_uViewUp;
uniform vec4 _111_scene_uInteriorSunDir;
uniform vec4 _111_scene_extLight_uExteriorAmbientColor;
uniform vec4 _111_scene_extLight_uExteriorHorizontAmbientColor;
uniform vec4 _111_scene_extLight_uExteriorGroundAmbientColor;
uniform vec4 _111_scene_extLight_uExteriorDirectColor;
uniform vec4 _111_scene_extLight_uExteriorDirectColorDir;
uniform vec4 _111_scene_extLight_adtSpecMult;
uniform vec4 _111_fogData_densityParams;
uniform vec4 _111_fogData_heightPlane;
uniform vec4 _111_fogData_color_and_heightRate;
uniform vec4 _111_fogData_heightDensity_and_endColor;
uniform vec4 _111_fogData_sunAngle_and_sunColor;
uniform vec4 _111_fogData_heightColor_and_endFogDistance;
uniform vec4 _111_fogData_sunPercentage;
uniform ivec4 _178_VertexShader_UseLitColor;
attribute vec3 aPosition;
varying vec4 vPosition;
varying vec3 vNormal;
attribute vec3 aNormal;
varying vec4 vColor;
attribute vec4 aColor;
varying vec4 vColor2;
attribute vec4 aColor2;
varying vec4 vColorSecond;
attribute vec4 aColorSecond;
varying vec2 vTexCoord4;
attribute vec2 aTexCoord4;
varying vec2 vTexCoord;
attribute vec2 aTexCoord;
varying vec2 vTexCoord2;
attribute vec2 aTexCoord2;
varying vec2 vTexCoord3;
attribute vec2 aTexCoord3;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

void main()
{
    vec4 worldPoint = _93_uPlacementMat * vec4(aPosition, 1.0);
    vec4 cameraPoint = _111_scene_uLookAtMat * worldPoint;
    mat4 viewModelMat = _111_scene_uLookAtMat * _93_uPlacementMat;
    mat4 param = _111_scene_uLookAtMat;
    mat4 param_1 = _93_uPlacementMat;
    mat3 viewModelMatTransposed = blizzTranspose(param) * blizzTranspose(param_1);
    gl_Position = _111_scene_uPMatrix * cameraPoint;
    vPosition = vec4(cameraPoint.xyz, 0.0);
    vNormal = normalize(viewModelMatTransposed * aNormal);
    vColor = aColor.zyxw;
    vColor2 = aColor2;
    vColorSecond = aColorSecond;
    vTexCoord4 = aTexCoord4;
    int uVertexShader = _178_VertexShader_UseLitColor.x;
    #if (VERTEXSHADER == (-1))
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 0)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 1)
    vTexCoord = aTexCoord;
    vTexCoord2 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 2)
    vTexCoord = aTexCoord;
    vec3 param_2 = vPosition.xyz;
    vec3 param_3 = vNormal;
    vTexCoord2 = posToTexCoord(param_2, param_3);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 3)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 4)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 5)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    #endif
    #if (VERTEXSHADER == 6)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 7)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 8)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
}


#version 300 es
precision mediump float;
precision highp int;

layout(std140) uniform modelWideBlockPS
{
    highp vec4 uViewUp;
    highp vec4 uSunDir_FogStart;
    highp vec4 uSunColor_uFogEnd;
    highp vec4 uAmbientLight;
    highp vec4 FogColor;
    int uNewFormula;
} _65;

uniform highp sampler2D uDiffuseTexture;
uniform highp sampler2D uNormalTexture;

in highp vec2 vChunkCoords;
in highp vec3 vPosition;
layout(location = 0) out highp vec4 fragColor;

void main()
{
    highp vec2 TextureCoords = vec2(vChunkCoords.x, vChunkCoords.y);
    highp vec4 texDiffuse = texture(uDiffuseTexture, TextureCoords);
    highp vec3 matDiffuse = texDiffuse.xyz;
    highp vec3 vNormal = (texture(uNormalTexture, TextureCoords).xyz * 2.0) - vec3(1.0);
    vNormal = vec3(-vNormal.z, -vNormal.x, vNormal.y);
    highp vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    highp vec3 fogColor = _65.FogColor.xyz;
    highp float fog_start = _65.uSunDir_FogStart.w;
    highp float fog_end = _65.uSunColor_uFogEnd.w;
    highp float fog_rate = 1.5;
    highp float fog_bias = 0.00999999977648258209228515625;
    highp float distanceToCamera = length(vPosition);
    highp float z_depth = distanceToCamera - fog_bias;
    highp float expFog = 1.0 / exp(max(0.0, z_depth - fog_start) * fog_rate);
    highp float heightFog = 1.0;
    expFog += heightFog;
    highp float endFadeFog = clamp((fog_end - distanceToCamera) / (0.699999988079071044921875 * fog_end), 0.0, 1.0);
    highp vec3 _123 = mix(fogColor, finalColor.xyz, vec3(min(expFog, endFadeFog)));
    finalColor = vec4(_123.x, _123.y, _123.z, finalColor.w);
    finalColor.w = 1.0;
    fragColor = finalColor;
}


#version 300 es

layout(std140) uniform modelWideBlockVS
{
    vec3 uPos;
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _55;

layout(location = 1) in float aIndex;
layout(location = 0) in float aHeight;
out vec2 vChunkCoords;
out vec3 vPosition;

void main()
{
    float stepX = floor(aIndex / 16641.0);
    float division = 129.0;
    bool _20 = stepX > 0.100000001490116119384765625;
    if (_20)
    {
        division = 128.0;
    }
    float offset = (stepX * 129.0) * 129.0;
    float iX = mod(aIndex - offset, division) + (stepX * 0.5);
    float iY = floor((aIndex - offset) / division) + (stepX * 0.5);
    vec4 worldPoint = vec4(_55.uPos.x - (iY * 4.166666507720947265625), _55.uPos.y - (iX * 4.166666507720947265625), aHeight, 1.0);
    vChunkCoords = vec2(iX / 128.0, iY / 128.0);
    vPosition = (_55.uLookAtMat * worldPoint).xyz;
    gl_Position = (_55.uPMatrix * _55.uLookAtMat) * worldPoint;
}


#version 300 es
precision mediump float;
precision highp int;

struct SceneExteriorLight
{
    highp vec4 uExteriorAmbientColor;
    highp vec4 uExteriorHorizontAmbientColor;
    highp vec4 uExteriorGroundAmbientColor;
    highp vec4 uExteriorDirectColor;
    highp vec4 uExteriorDirectColorDir;
    highp vec4 adtSpecMult;
};

struct SceneWideParams
{
    highp mat4 uLookAtMat;
    highp mat4 uPMatrix;
    highp vec4 uViewUp;
    highp vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    highp vec4 uInteriorAmbientColorAndApplyInteriorLight;
    highp vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    highp vec4 densityParams;
    highp vec4 heightPlane;
    highp vec4 color_and_heightRate;
    highp vec4 heightDensity_and_endColor;
    highp vec4 sunAngle_and_sunColor;
    highp vec4 heightColor_and_endFogDistance;
    highp vec4 sunPercentage;
};

const vec3 _222[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _229[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

layout(std140) uniform meshWideBlockPS
{
    highp vec4 uHeightScale;
    highp vec4 uHeightOffset;
    highp mat4 animationMat[4];
} _466;

layout(std140) uniform modelWideBlockPS
{
    ivec4 uUseHeightMixFormula;
} _506;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _748;

uniform highp sampler2D uAlphaTexture;
uniform highp sampler2D uLayerHeight0;
uniform highp sampler2D uLayerHeight1;
uniform highp sampler2D uLayerHeight2;
uniform highp sampler2D uLayerHeight3;
uniform highp sampler2D uLayer0;
uniform highp sampler2D uLayer1;
uniform highp sampler2D uLayer2;
uniform highp sampler2D uLayer3;

in highp vec2 vChunkCoords;
in highp vec4 vColor;
in highp vec3 vNormal;
in highp vec3 vVertexLighting;
in highp vec3 vPosition;
layout(location = 0) out highp vec4 outColor;

highp vec4 mixTextures(highp vec4 tex0, highp vec4 tex1, highp float alpha)
{
    return ((tex1 - tex0) * alpha) + tex0;
}

highp vec3 calcLight(highp vec3 matDiffuse, highp vec3 vNormal_1, bool applyLight, highp float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, highp vec3 accumLight, highp vec3 precomputedLight, highp vec3 specular, highp vec3 emissive)
{
    highp vec3 localDiffuse = accumLight;
    bool _58 = !applyLight;
    if (_58)
    {
        return matDiffuse;
    }
    highp vec3 lDiffuse = vec3(0.0);
    highp vec3 normalizedN = normalize(vNormal_1);
    bool _74 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    highp vec3 currColor;
    if (_74)
    {
        highp float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        highp float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        highp vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        highp vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        highp vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _111 = nDotUp >= 0.0;
        if (_111)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        highp vec3 skyColor = currColor * 1.10000002384185791015625;
        highp vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _151 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_151)
    {
        highp float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        highp vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        highp vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _175 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_175)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    highp vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    highp vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    highp vec3 specTerm = specular;
    highp vec3 emTerm = emissive;
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

highp vec3 validateFogColor(highp vec3 fogColor, int blendMode)
{
    return mix(fogColor, _222[blendMode], vec3(_229[blendMode]));
}

highp vec4 makeFog(PSFog fogData, highp vec4 final, highp vec3 vertexInViewSpace, highp vec3 sunDirInViewSpace, int blendMode)
{
    highp vec4 l_densityParams = fogData.densityParams;
    highp vec4 l_heightPlane = fogData.heightPlane;
    highp vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    highp vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    highp float start = l_densityParams.x;
    highp float end = l_densityParams.y;
    highp float density = l_densityParams.z;
    highp float bias = l_densityParams.w;
    highp float vLength = length(vertexInViewSpace);
    highp float z = vLength - bias;
    highp float expMax = max(0.0, z - start);
    highp float expFog = 1.0 / exp(expMax * density);
    highp float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    highp float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    highp float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    highp float finalFog = mix(expFog, expFogHeight, heightFog);
    highp float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    highp float alpha = 1.0;
    bool _317 = blendMode == 13;
    if (_317)
    {
        alpha = min(finalFog, endFadeFog);
    }
    highp vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    highp vec3 endColor = validateFogColor(param, param_1);
    highp vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    highp float end2 = vLength / l_heightColor_and_endFogDistance.w;
    highp float end2_cube = end2 * (end2 * end2);
    highp vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    highp vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    highp vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    highp vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    highp float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    highp vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    highp vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _395 = nDotSun > 0.0;
    if (_395)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final.xyz, vec3(min(finalFog, endFadeFog)));
    return vec4(fogFinal, final.w * alpha);
}

void main()
{
    highp vec2 vTexCoord = vChunkCoords;
    highp vec2 alphaCoord = vec2(vChunkCoords.x / 8.0, vChunkCoords.y / 8.0);
    highp vec3 alphaBlend = texture(uAlphaTexture, alphaCoord).yzw;
    highp vec2 tcLayer0 = (_466.animationMat[0] * vec4(vTexCoord, 0.0, 1.0)).xy;
    highp vec2 tcLayer1 = (_466.animationMat[1] * vec4(vTexCoord, 0.0, 1.0)).xy;
    highp vec2 tcLayer2 = (_466.animationMat[2] * vec4(vTexCoord, 0.0, 1.0)).xy;
    highp vec2 tcLayer3 = (_466.animationMat[3] * vec4(vTexCoord, 0.0, 1.0)).xy;
    bool _510 = _506.uUseHeightMixFormula.x > 0;
    highp vec4 final;
    if (_510)
    {
        highp float minusAlphaBlendSum = 1.0 - clamp(dot(alphaBlend, vec3(1.0)), 0.0, 1.0);
        highp vec4 weightsVector = vec4(minusAlphaBlendSum, alphaBlend);
        highp float weightedTexture_x = minusAlphaBlendSum * ((texture(uLayerHeight0, tcLayer0).w * _466.uHeightScale.x) + _466.uHeightOffset.x);
        highp float weightedTexture_y = weightsVector.y * ((texture(uLayerHeight1, tcLayer1).w * _466.uHeightScale.y) + _466.uHeightOffset.y);
        highp float weightedTexture_z = weightsVector.z * ((texture(uLayerHeight2, tcLayer2).w * _466.uHeightScale.z) + _466.uHeightOffset.z);
        highp float weightedTexture_w = weightsVector.w * ((texture(uLayerHeight3, tcLayer3).w * _466.uHeightScale.w) + _466.uHeightOffset.w);
        highp vec4 weights = vec4(weightedTexture_x, weightedTexture_y, weightedTexture_z, weightedTexture_w);
        highp vec4 weights_temp = weights * (vec4(1.0) - clamp(vec4(max(max(weightedTexture_x, weightedTexture_y), max(weightedTexture_z, weightedTexture_w))) - weights, vec4(0.0), vec4(1.0)));
        highp vec4 weightsNormalized = weights_temp / vec4(dot(vec4(1.0), weights_temp));
        highp vec4 weightedLayer_0 = texture(uLayer0, tcLayer0) * weightsNormalized.x;
        highp vec3 matDiffuse_0 = weightedLayer_0.xyz;
        highp float specBlend_0 = weightedLayer_0.w;
        highp vec4 weightedLayer_1 = texture(uLayer1, tcLayer1) * weightsNormalized.y;
        highp vec3 matDiffuse_1 = matDiffuse_0 + weightedLayer_1.xyz;
        highp float specBlend_1 = specBlend_0 + weightedLayer_1.w;
        highp vec4 weightedLayer_2 = texture(uLayer2, tcLayer2) * weightsNormalized.z;
        highp vec3 matDiffuse_2 = matDiffuse_1 + weightedLayer_2.xyz;
        highp float specBlend_2 = specBlend_1 + weightedLayer_2.w;
        highp vec4 weightedLayer_3 = texture(uLayer3, tcLayer3) * weightsNormalized.w;
        highp vec3 matDiffuse_3 = matDiffuse_2 + weightedLayer_3.xyz;
        highp float specBlend_3 = specBlend_2 + weightedLayer_3.w;
        final = vec4(matDiffuse_3, specBlend_3);
    }
    else
    {
        highp vec4 tex1 = texture(uLayer0, tcLayer0);
        highp vec4 tex2 = texture(uLayer1, tcLayer1);
        highp vec4 tex3 = texture(uLayer2, tcLayer2);
        highp vec4 tex4 = texture(uLayer3, tcLayer3);
        highp vec4 param = tex1;
        highp vec4 param_1 = tex2;
        highp float param_2 = alphaBlend.x;
        highp vec4 param_3 = mixTextures(param, param_1, param_2);
        highp vec4 param_4 = tex3;
        highp float param_5 = alphaBlend.y;
        highp vec4 param_6 = mixTextures(param_3, param_4, param_5);
        highp vec4 param_7 = tex4;
        highp float param_8 = alphaBlend.z;
        final = mixTextures(param_6, param_7, param_8);
    }
    highp vec3 matDiffuse = (final.xyz * 2.0) * vColor.xyz;
    highp vec3 param_9 = matDiffuse;
    highp vec3 param_10 = vNormal;
    bool param_11 = true;
    highp float param_12 = 0.0;
    SceneWideParams param_13;
    param_13.uLookAtMat = _748.scene.uLookAtMat;
    param_13.uPMatrix = _748.scene.uPMatrix;
    param_13.uViewUp = _748.scene.uViewUp;
    param_13.uInteriorSunDir = _748.scene.uInteriorSunDir;
    param_13.extLight.uExteriorAmbientColor = _748.scene.extLight.uExteriorAmbientColor;
    param_13.extLight.uExteriorHorizontAmbientColor = _748.scene.extLight.uExteriorHorizontAmbientColor;
    param_13.extLight.uExteriorGroundAmbientColor = _748.scene.extLight.uExteriorGroundAmbientColor;
    param_13.extLight.uExteriorDirectColor = _748.scene.extLight.uExteriorDirectColor;
    param_13.extLight.uExteriorDirectColorDir = _748.scene.extLight.uExteriorDirectColorDir;
    param_13.extLight.adtSpecMult = _748.scene.extLight.adtSpecMult;
    InteriorLightParam param_14 = InteriorLightParam(vec4(0.0), vec4(0.0, 0.0, 0.0, 1.0));
    highp vec3 param_15 = vVertexLighting;
    highp vec4 finalColor = vec4(calcLight(param_9, param_10, param_11, param_12, param_13, param_14, param_15, vec3(0.0), vec3(0.0), vec3(0.0)), 1.0);
    highp float specBlend = final.w;
    highp vec3 halfVec = -normalize(_748.scene.extLight.uExteriorDirectColorDir.xyz + normalize(vPosition));
    highp vec3 lSpecular = _748.scene.extLight.uExteriorDirectColor.xyz * pow(max(0.0, dot(halfVec, vNormal)), 20.0);
    highp vec3 specTerm = (vec3(specBlend) * lSpecular) * _748.scene.extLight.adtSpecMult.x;
    highp vec3 _831 = finalColor.xyz + specTerm;
    finalColor = vec4(_831.x, _831.y, _831.z, finalColor.w);
    PSFog arg;
    arg.densityParams = _748.fogData.densityParams;
    arg.heightPlane = _748.fogData.heightPlane;
    arg.color_and_heightRate = _748.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _748.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _748.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _748.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _748.fogData.sunPercentage;
    highp vec4 param_16 = finalColor;
    highp vec3 param_17 = vPosition;
    highp vec3 param_18 = _748.scene.extLight.uExteriorDirectColorDir.xyz;
    int param_19 = 0;
    finalColor = makeFog(arg, param_16, param_17, param_18, param_19);
    finalColor.w = 1.0;
    outColor = finalColor;
}


#version 300 es

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _91;

layout(std140) uniform meshWideBlockVS
{
    vec4 uPos;
} _139;

layout(location = 4) in float aIndex;
layout(location = 0) in vec3 aHeight;
out vec2 vChunkCoords;
out vec3 vPosition;
out vec4 vColor;
layout(location = 1) in vec4 aColor;
out vec3 vVertexLighting;
layout(location = 2) in vec4 aVertexLighting;
out vec3 vNormal;
layout(location = 3) in vec3 aNormal;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

void main()
{
    float iX = mod(aIndex, 17.0);
    float iY = floor(aIndex / 17.0);
    bool _61 = iX > 8.0100002288818359375;
    if (_61)
    {
        iY += 0.5;
        iX -= 8.5;
    }
    vec4 worldPoint = vec4(aHeight, 1.0);
    vChunkCoords = vec2(iX, iY);
    vPosition = (_91.scene.uLookAtMat * worldPoint).xyz;
    vColor = aColor;
    vVertexLighting = aVertexLighting.xyz;
    mat4 param = _91.scene.uLookAtMat;
    vNormal = blizzTranspose(param) * aNormal;
    gl_Position = (_91.scene.uPMatrix * _91.scene.uLookAtMat) * worldPoint;
}


#version 300 es
precision mediump float;
precision highp int;

layout(std140) uniform modelWideBlockVS
{
    highp mat4 uPlacementMat;
    highp vec4 uBBScale;
    highp vec4 uBBCenter;
    highp vec4 uColor;
} _13;

layout(location = 0) out highp vec4 outColor;

void main()
{
    highp vec4 finalColor = _13.uColor;
    outColor = finalColor;
}


#version 300 es

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
} _21;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _62;

layout(location = 0) in vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4((aPosition.x * _21.uBBScale.x) + _21.uBBCenter.x, (aPosition.y * _21.uBBScale.y) + _21.uBBCenter.y, (aPosition.z * _21.uBBScale.z) + _21.uBBCenter.z, 1.0);
    gl_Position = ((_62.scene.uPMatrix * _62.scene.uLookAtMat) * _21.uPlacementMat) * worldPoint;
}


#version 300 es
precision mediump float;
precision highp int;

layout(std140) uniform meshWideBlockPS
{
    int drawDepth;
    highp float uFarPlane;
    highp float uNearPlane;
} _10;

uniform highp sampler2D diffuse;

in highp vec2 texCoord;
layout(location = 0) out highp vec4 fragColor;

void main()
{
    bool _17 = _10.drawDepth == 1;
    highp vec4 finalColor;
    if (_17)
    {
        highp float f = _10.uFarPlane;
        highp float n = _10.uNearPlane;
        highp float z = (2.0 * n) / ((f + n) - (texture(diffuse, texCoord).x * (f - n)));
        finalColor = vec4(z, z, z, 255.0);
    }
    else
    {
        finalColor = vec4(texture(diffuse, texCoord).xyz, 255.0);
    }
    fragColor = finalColor;
}


#version 300 es
precision mediump float;
precision highp int;

layout(std140) uniform meshWideBlockPS
{
    highp vec3 uColor;
} _22;

layout(location = 0) out highp vec4 fragColor;

void main()
{
    highp vec4 finalColor = vec4(1.0);
    finalColor.w = 1.0;
    fragColor = finalColor;
}


#version 300 es

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _13;

layout(location = 0) in vec3 aPosition;

void main()
{
    vec4 c_world = inverse(_13.uPMatrix) * vec4(aPosition, 1.0);
    c_world = (c_world * 1.0) / vec4(c_world.w);
    gl_Position = (_13.uPMatrix * _13.uLookAtMat) * vec4(c_world.xyz, 1.0);
}


#version 300 es
precision mediump float;
precision highp int;

layout(std140) uniform modelWideBlockPS
{
    highp vec3 uColor;
} _19;

layout(location = 0) out highp vec4 fragColor;

void main()
{
    highp vec4 finalColor = vec4(1.0, 1.0, 0.0, 1.0);
    fragColor = finalColor;
}


#version 300 es

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _19;

layout(location = 0) in vec2 aPosition;

void main()
{
    gl_Position = (_19.uPMatrix * _19.uLookAtMat) * vec4(aPosition, 0.0, 1.0);
}


#version 300 es
precision mediump float;
precision highp int;

layout(std140) uniform modelWideBlockVS
{
    highp vec3 uColor;
} _13;

layout(location = 0) out highp vec4 fragColor;
in highp vec4 vPos;

void main()
{
    fragColor = vec4(_13.uColor, 1.0);
}


#version 300 es

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _19;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _29;

layout(location = 0) in vec3 aPosition;
out vec4 vPos;

void main()
{
    gl_Position = ((_19.uPMatrix * _19.uLookAtMat) * _29.uPlacementMat) * vec4(aPosition, 1.0);
    gl_PointSize = 10.0;
}


#version 300 es
precision mediump float;
precision highp int;

layout(std140) uniform meshWideBlockPS
{
    highp vec4 uColor;
} _12;

layout(location = 0) out highp vec4 fragColor;

void main()
{
    highp vec4 finalColor = _12.uColor;
    fragColor = finalColor;
}


#version 300 es

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _30;

layout(location = 0) in vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4(aPosition, 1.0);
    gl_Position = (_30.uPMatrix * _30.uLookAtMat) * worldPoint;
}


#version 300 es

layout(std140) uniform meshWideBlockVS
{
    vec4 uWidth_uHeight_uX_uY;
} _12;

out vec2 texCoord;
layout(location = 0) in vec2 position;

void main()
{
    float uWidth = _12.uWidth_uHeight_uX_uY.x;
    float uHeight = _12.uWidth_uHeight_uX_uY.y;
    float uX = _12.uWidth_uHeight_uX_uY.z;
    float uY = _12.uWidth_uHeight_uX_uY.w;
    texCoord = (position * 0.5) + vec2(0.5);
    gl_Position = vec4((((((position.x + 1.0) / 2.0) * uWidth) + uX) * 2.0) - 1.0, (((((position.y + 1.0) / 2.0) * uHeight) + uY) * 2.0) - 1.0, 0.5, 1.0);
}


#version 300 es
precision mediump float;
precision highp int;

layout(std140) uniform meshWideBlockPS
{
    highp vec4 texOffsetX;
    highp vec4 texOffsetY;
} _33;

uniform highp sampler2D texture0;

in highp vec2 texCoord;
layout(location = 0) out highp vec4 out_result;

void main()
{
    highp vec2 tex_offset = vec2(0.001000000047497451305389404296875);
    highp vec3 result = texture(texture0, texCoord).xyz * 0.0;
    result = vec3(0.0);
    result += (texture(texture0, texCoord + vec2(_33.texOffsetX.x * tex_offset.x, _33.texOffsetY.x * tex_offset.y)).xyz * 0.125);
    result += (texture(texture0, texCoord + vec2(_33.texOffsetX.y * tex_offset.x, _33.texOffsetY.y * tex_offset.y)).xyz * 0.375);
    result += (texture(texture0, texCoord + vec2(_33.texOffsetX.z * tex_offset.x, _33.texOffsetY.z * tex_offset.y)).xyz * 0.375);
    result += (texture(texture0, texCoord + vec2(_33.texOffsetX.w * tex_offset.x, _33.texOffsetY.w * tex_offset.y)).xyz * 0.125);
    out_result = vec4(result, 1.0);
}


#version 300 es
precision mediump float;
precision highp int;

layout(std140) uniform meshWideBlockPS
{
    highp vec4 blurAmount;
} _34;

uniform highp sampler2D screenTex;
uniform highp sampler2D blurTex;

in highp vec2 texCoord;
layout(location = 0) out highp vec4 Out_Color;

void main()
{
    highp vec4 screen = texture(screenTex, texCoord);
    highp vec3 blurred = texture(blurTex, texCoord).xyz;
    highp vec3 mixed = mix(screen.xyz, blurred, vec3(_34.blurAmount.z));
    highp vec3 glow = (blurred * blurred) * _34.blurAmount.w;
    Out_Color = vec4(mixed + glow, screen.w);
}


#version 300 es
precision mediump float;
precision highp int;

uniform highp sampler2D Texture;

layout(location = 0) out highp vec4 Out_Color;
in highp vec4 Frag_Color;
in highp vec2 Frag_UV;

void main()
{
    Out_Color = Frag_Color * texture(Texture, Frag_UV);
}


#version 300 es

layout(std140) uniform modelWideBlockVS
{
    mat4 ProjMtx;
    vec4 uiScale;
} _30;

out vec2 Frag_UV;
layout(location = 1) in vec2 UV;
out vec4 Frag_Color;
layout(location = 2) in vec4 Color;
layout(location = 0) in vec2 Position;

void main()
{
    Frag_UV = UV;
    Frag_Color = Color;
    gl_Position = _30.ProjMtx * vec4(Position * _30.uiScale.x, 0.0, 1.0);
}


#version 300 es
precision mediump float;
precision highp int;

struct PSFog
{
    highp vec4 densityParams;
    highp vec4 heightPlane;
    highp vec4 color_and_heightRate;
    highp vec4 heightDensity_and_endColor;
    highp vec4 sunAngle_and_sunColor;
    highp vec4 heightColor_and_endFogDistance;
    highp vec4 sunPercentage;
};

const vec3 _37[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _44[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct SceneExteriorLight
{
    highp vec4 uExteriorAmbientColor;
    highp vec4 uExteriorHorizontAmbientColor;
    highp vec4 uExteriorGroundAmbientColor;
    highp vec4 uExteriorDirectColor;
    highp vec4 uExteriorDirectColorDir;
    highp vec4 adtSpecMult;
};

struct SceneWideParams
{
    highp mat4 uLookAtMat;
    highp mat4 uPMatrix;
    highp vec4 uViewUp;
    highp vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

layout(std140) uniform meshWideBlockPS
{
    highp vec4 uAlphaTestv;
    ivec4 uPixelShaderBlendModev;
} _277;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _485;

uniform highp sampler2D uTexture;
uniform highp sampler2D uTexture2;
uniform highp sampler2D uTexture3;

in highp vec2 vTexcoord0;
in highp vec2 vTexcoord1;
in highp vec2 vTexcoord2;
in highp vec4 vColor;
in highp vec3 vPosition;
layout(location = 0) out highp vec4 outputColor;

highp vec3 validateFogColor(highp vec3 fogColor, int blendMode)
{
    return mix(fogColor, _37[blendMode], vec3(_44[blendMode]));
}

highp vec4 makeFog(PSFog fogData, highp vec4 final, highp vec3 vertexInViewSpace, highp vec3 sunDirInViewSpace, int blendMode)
{
    highp vec4 l_densityParams = fogData.densityParams;
    highp vec4 l_heightPlane = fogData.heightPlane;
    highp vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    highp vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    highp float start = l_densityParams.x;
    highp float end = l_densityParams.y;
    highp float density = l_densityParams.z;
    highp float bias = l_densityParams.w;
    highp float vLength = length(vertexInViewSpace);
    highp float z = vLength - bias;
    highp float expMax = max(0.0, z - start);
    highp float expFog = 1.0 / exp(expMax * density);
    highp float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    highp float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    highp float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    highp float finalFog = mix(expFog, expFogHeight, heightFog);
    highp float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    highp float alpha = 1.0;
    bool _139 = blendMode == 13;
    if (_139)
    {
        alpha = min(finalFog, endFadeFog);
    }
    highp vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    highp vec3 endColor = validateFogColor(param, param_1);
    highp vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    highp float end2 = vLength / l_heightColor_and_endFogDistance.w;
    highp float end2_cube = end2 * (end2 * end2);
    highp vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    highp vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    highp vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    highp vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    highp float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    highp vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    highp vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _218 = nDotSun > 0.0;
    if (_218)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final.xyz, vec3(min(finalFog, endFadeFog)));
    return vec4(fogFinal, final.w * alpha);
}

void main()
{
    highp vec4 tex = texture(uTexture, vTexcoord0);
    highp vec4 tex2 = texture(uTexture2, vTexcoord1);
    highp vec4 tex3 = texture(uTexture3, vTexcoord2);
    highp float uAlphaTest = _277.uAlphaTestv.x;
    bool _284 = tex.w < uAlphaTest;
    if (_284)
    {
        discard;
    }
    highp vec4 finalColor = vec4((tex * vColor).xyz, tex.w * vColor.w);
    int uNonOptPixelShader = _277.uPixelShaderBlendModev.x;
    bool _310 = uNonOptPixelShader == 0;
    if (_310)
    {
        highp vec3 matDiffuse = vColor.xyz * tex.xyz;
        finalColor = vec4(matDiffuse, tex.w * vColor.w);
    }
    else
    {
        bool _331 = uNonOptPixelShader == 1;
        if (_331)
        {
            highp vec4 textureMod = tex * tex2;
            highp float texAlpha = textureMod.w * tex3.w;
            highp float opacity = texAlpha * vColor.w;
            highp vec3 matDiffuse_1 = vColor.xyz * textureMod.xyz;
            finalColor = vec4(matDiffuse_1, opacity);
        }
        else
        {
            bool _363 = uNonOptPixelShader == 2;
            if (_363)
            {
                highp vec4 textureMod_1 = (tex * tex2) * tex3;
                highp float texAlpha_1 = textureMod_1.w;
                highp float opacity_1 = texAlpha_1 * vColor.w;
                highp vec3 matDiffuse_2 = vColor.xyz * textureMod_1.xyz;
                finalColor = vec4(matDiffuse_2, opacity_1);
            }
            else
            {
                bool _394 = uNonOptPixelShader == 3;
                if (_394)
                {
                    highp vec4 textureMod_2 = (tex * tex2) * tex3;
                    highp float texAlpha_2 = textureMod_2.w;
                    highp float opacity_2 = texAlpha_2 * vColor.w;
                    highp vec3 matDiffuse_3 = vColor.xyz * textureMod_2.xyz;
                    finalColor = vec4(matDiffuse_3, opacity_2);
                }
                else
                {
                    bool _425 = uNonOptPixelShader == 4;
                    if (_425)
                    {
                        highp float t0_973 = tex.x;
                        highp float t1_978 = tex2.y;
                        highp float t2_983 = tex3.z;
                        highp float textureMod_986 = ((t0_973 * t1_978) * t2_983) * 4.0;
                        highp float depthScale_991 = 1.0 - clamp(vPosition.z * 0.00999999977648258209228515625, 0.0, 1.0);
                        highp float textureMod_992 = textureMod_986 * depthScale_991;
                        highp float height_995 = textureMod_992 * vColor.x;
                        highp float alpha_997 = textureMod_992 * vColor.w;
                        finalColor = vec4(height_995, 0.0, 0.0, alpha_997);
                    }
                }
            }
        }
    }
    bool _474 = finalColor.w < uAlphaTest;
    if (_474)
    {
        discard;
    }
    highp vec3 sunDir = _485.scene.extLight.uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _485.fogData.densityParams;
    arg.heightPlane = _485.fogData.heightPlane;
    arg.color_and_heightRate = _485.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _485.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _485.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _485.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _485.fogData.sunPercentage;
    highp vec4 param = finalColor;
    highp vec3 param_1 = vPosition;
    highp vec3 param_2 = sunDir;
    int param_3 = _277.uPixelShaderBlendModev.y;
    finalColor = makeFog(arg, param, param_1, param_2, param_3);
    outputColor = finalColor;
}


#version 300 es

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _43;

layout(location = 0) in vec3 aPosition;
out vec4 vColor;
layout(location = 1) in vec4 aColor;
out vec2 vTexcoord0;
layout(location = 2) in vec2 aTexcoord0;
out vec2 vTexcoord1;
layout(location = 3) in vec2 aTexcoord1;
out vec2 vTexcoord2;
layout(location = 4) in vec2 aTexcoord2;
out vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vTexcoord1 = aTexcoord1;
    vTexcoord2 = aTexcoord2;
    vec4 vertexViewSpace = _43.scene.uLookAtMat * aPositionVec4;
    vPosition = vertexViewSpace.xyz;
    gl_Position = _43.scene.uPMatrix * vertexViewSpace;
}


#version 300 es
precision mediump float;
precision highp int;

struct SceneExteriorLight
{
    highp vec4 uExteriorAmbientColor;
    highp vec4 uExteriorHorizontAmbientColor;
    highp vec4 uExteriorGroundAmbientColor;
    highp vec4 uExteriorDirectColor;
    highp vec4 uExteriorDirectColorDir;
    highp vec4 adtSpecMult;
};

struct SceneWideParams
{
    highp mat4 uLookAtMat;
    highp mat4 uPMatrix;
    highp vec4 uViewUp;
    highp vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    highp vec4 uInteriorAmbientColorAndApplyInteriorLight;
    highp vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    highp vec4 densityParams;
    highp vec4 heightPlane;
    highp vec4 color_and_heightRate;
    highp vec4 heightDensity_and_endColor;
    highp vec4 sunAngle_and_sunColor;
    highp vec4 heightColor_and_endFogDistance;
    highp vec4 sunPercentage;
};

const vec3 _216[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _223[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct LocalLight
{
    highp vec4 color;
    highp vec4 position;
    highp vec4 attenuation;
};

layout(std140) uniform meshWideBlockPS
{
    ivec4 PixelShader_UnFogged_IsAffectedByLight_blendMode;
    highp vec4 uFogColorAndAlphaTest;
    highp vec4 uTexSampleAlpha;
    highp vec4 uPcColor;
} _473;

layout(std140) uniform modelWideBlockPS
{
    InteriorLightParam intLight;
    LocalLight pc_lights[4];
    ivec4 lightCountAndBcHack;
    highp vec4 interiorExteriorBlend;
} _496;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _535;

layout(std140) uniform modelWideBlockVS
{
    highp mat4 uPlacementMat;
    highp mat4 uBoneMatrixes[220];
} _543;

uniform highp sampler2D uTexture;
uniform highp sampler2D uTexture2;
uniform highp sampler2D uTexture3;
uniform highp sampler2D uTexture4;

in highp vec2 vTexCoord;
in highp vec2 vTexCoord2;
in highp vec2 vTexCoord3;
in highp vec4 vDiffuseColor;
in highp vec3 vPosition;
in highp vec3 vNormal;
layout(location = 0) out highp vec4 outputColor;

highp vec3 calcLight(highp vec3 matDiffuse, highp vec3 vNormal_1, bool applyLight, highp float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, highp vec3 accumLight, highp vec3 precomputedLight, highp vec3 specular, highp vec3 emissive)
{
    highp vec3 localDiffuse = accumLight;
    bool _52 = !applyLight;
    if (_52)
    {
        return matDiffuse;
    }
    highp vec3 lDiffuse = vec3(0.0);
    highp vec3 normalizedN = normalize(vNormal_1);
    bool _68 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    highp vec3 currColor;
    if (_68)
    {
        highp float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        highp float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        highp vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        highp vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        highp vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _105 = nDotUp >= 0.0;
        if (_105)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        highp vec3 skyColor = currColor * 1.10000002384185791015625;
        highp vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _145 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_145)
    {
        highp float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        highp vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        highp vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _169 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_169)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    highp vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    highp vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    highp vec3 specTerm = specular;
    highp vec3 emTerm = emissive;
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

highp vec3 validateFogColor(highp vec3 fogColor, int blendMode)
{
    return mix(fogColor, _216[blendMode], vec3(_223[blendMode]));
}

highp vec4 makeFog(PSFog fogData, highp vec4 final, highp vec3 vertexInViewSpace, highp vec3 sunDirInViewSpace, int blendMode)
{
    highp vec4 l_densityParams = fogData.densityParams;
    highp vec4 l_heightPlane = fogData.heightPlane;
    highp vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    highp vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    highp float start = l_densityParams.x;
    highp float end = l_densityParams.y;
    highp float density = l_densityParams.z;
    highp float bias = l_densityParams.w;
    highp float vLength = length(vertexInViewSpace);
    highp float z = vLength - bias;
    highp float expMax = max(0.0, z - start);
    highp float expFog = 1.0 / exp(expMax * density);
    highp float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    highp float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    highp float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    highp float finalFog = mix(expFog, expFogHeight, heightFog);
    highp float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    highp float alpha = 1.0;
    bool _311 = blendMode == 13;
    if (_311)
    {
        alpha = min(finalFog, endFadeFog);
    }
    highp vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    highp vec3 endColor = validateFogColor(param, param_1);
    highp vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    highp float end2 = vLength / l_heightColor_and_endFogDistance.w;
    highp float end2_cube = end2 * (end2 * end2);
    highp vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    highp vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    highp vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    highp vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    highp float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    highp vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    highp vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _389 = nDotSun > 0.0;
    if (_389)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final.xyz, vec3(min(finalFog, endFadeFog)));
    return vec4(fogFinal, final.w * alpha);
}

void main()
{
    highp vec2 texCoord = vTexCoord;
    highp vec2 texCoord2 = vTexCoord2;
    highp vec2 texCoord3 = vTexCoord3;
    highp vec4 tex = texture(uTexture, texCoord);
    highp vec4 tex2 = texture(uTexture2, texCoord2);
    highp vec4 tex3 = texture(uTexture3, texCoord3);
    highp vec4 tex2WithTextCoord1 = texture(uTexture2, texCoord);
    highp vec4 tex3WithTextCoord1 = texture(uTexture3, texCoord);
    highp vec4 tex4WithTextCoord2 = texture(uTexture4, texCoord2);
    highp vec4 finalColor = vec4(0.0);
    highp vec4 meshResColor = vDiffuseColor;
    bool _477 = _473.PixelShader_UnFogged_IsAffectedByLight_blendMode.z == 1;
    highp vec3 accumLight;
    if (_477)
    {
        highp vec3 vPos3 = vPosition;
        highp vec3 vNormal3 = normalize(vNormal);
        highp vec3 lightColor = vec3(0.0);
        int count = int(_496.pc_lights[0].attenuation.w);
        LocalLight lightRecord;
        for (int index = 0; index < 4; index++)
        {
            bool _512 = index >= _496.lightCountAndBcHack.x;
            if (_512)
            {
                break;
            }
            lightRecord.color = _496.pc_lights[index].color;
            lightRecord.position = _496.pc_lights[index].position;
            lightRecord.attenuation = _496.pc_lights[index].attenuation;
            highp vec3 vectorToLight = (_535.scene.uLookAtMat * (_543.uPlacementMat * lightRecord.position)).xyz - vPos3;
            highp float distanceToLightSqr = dot(vectorToLight, vectorToLight);
            highp float distanceToLightInv = inversesqrt(distanceToLightSqr);
            highp float distanceToLight = distanceToLightSqr * distanceToLightInv;
            highp float diffuseTerm1 = max(dot(vectorToLight, vNormal3) * distanceToLightInv, 0.0);
            highp vec4 attenuationRec = lightRecord.attenuation;
            highp float attenuation = 1.0 - clamp((distanceToLight - attenuationRec.x) * (1.0 / (attenuationRec.z - attenuationRec.x)), 0.0, 1.0);
            highp vec3 attenuatedColor = lightRecord.color.xyz * attenuation;
            lightColor += vec3((attenuatedColor * attenuatedColor) * diffuseTerm1);
        }
        highp vec3 _610 = clamp(lightColor, vec3(0.0), vec3(1.0));
        meshResColor = vec4(_610.x, _610.y, _610.z, meshResColor.w);
        accumLight = mix(lightColor, meshResColor.xyz, vec3(float(_496.lightCountAndBcHack.y)));
    }
    highp float finalOpacity = 0.0;
    highp vec3 specular = vec3(0.0);
    highp vec3 visParams = vec3(1.0);
    highp vec4 genericParams[3];
    genericParams[0] = vec4(1.0);
    genericParams[1] = vec4(1.0);
    genericParams[2] = vec4(1.0);
    bool canDiscard = false;
    highp float discardAlpha = 1.0;
    int uPixelShader = _473.PixelShader_UnFogged_IsAffectedByLight_blendMode.x;
    bool _639 = uPixelShader == 0;
    highp vec3 matDiffuse;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    #endif
    bool _652 = uPixelShader == 1;
    #if (FRAGMENTSHADER == 1)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w;
    canDiscard = true;
    #endif
    bool _666 = uPixelShader == 2;
    #if (FRAGMENTSHADER == 2)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    discardAlpha = tex2.w;
    canDiscard = true;
    #endif
    bool _682 = uPixelShader == 3;
    #if (FRAGMENTSHADER == 3)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    discardAlpha = tex2.w * 2.0;
    canDiscard = true;
    #endif
    bool _700 = uPixelShader == 4;
    #if (FRAGMENTSHADER == 4)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    #endif
    bool _715 = uPixelShader == 5;
    #if (FRAGMENTSHADER == 5)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    #endif
    bool _729 = uPixelShader == 6;
    #if (FRAGMENTSHADER == 6)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    discardAlpha = tex.w * tex2.w;
    canDiscard = true;
    #endif
    bool _749 = uPixelShader == 7;
    #if (FRAGMENTSHADER == 7)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    discardAlpha = (tex.w * tex2.w) * 2.0;
    canDiscard = true;
    #endif
    bool _771 = uPixelShader == 8;
    #if (FRAGMENTSHADER == 8)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w + tex2.w;
    canDiscard = true;
    specular = tex2.xyz;
    #endif
    bool _790 = uPixelShader == 9;
    #if (FRAGMENTSHADER == 9)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    discardAlpha = tex.w;
    canDiscard = true;
    #endif
    bool _808 = uPixelShader == 10;
    #if (FRAGMENTSHADER == 10)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w;
    canDiscard = true;
    specular = tex2.xyz;
    #endif
    bool _824 = uPixelShader == 11;
    #if (FRAGMENTSHADER == 11)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    discardAlpha = tex.w;
    canDiscard = true;
    #endif
    bool _841 = uPixelShader == 12;
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    #endif
    bool _862 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = tex2.xyz * tex2.w;
    #endif
    bool _879 = uPixelShader == 14;
    #if (FRAGMENTSHADER == 14)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    #endif
    bool _900 = uPixelShader == 15;
    #if (FRAGMENTSHADER == 15)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    specular = (tex3.xyz * tex3.w) * _473.uTexSampleAlpha.z;
    #endif
    bool _930 = uPixelShader == 16;
    #if (FRAGMENTSHADER == 16)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w;
    canDiscard = true;
    specular = tex2.xyz * tex2.w;
    #endif
    bool _949 = uPixelShader == 17;
    #if (FRAGMENTSHADER == 17)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w + (tex2.w * (((0.300000011920928955078125 * tex2.x) + (0.589999973773956298828125 * tex2.y)) + (0.10999999940395355224609375 * tex2.z)));
    canDiscard = true;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    #endif
    bool _990 = uPixelShader == 18;
    #if (FRAGMENTSHADER == 18)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex.xyz, tex2.xyz, vec3(tex2.w)), tex.xyz, vec3(tex.w));
    #endif
    bool _1014 = uPixelShader == 19;
    #if (FRAGMENTSHADER == 19)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w));
    #endif
    bool _1036 = uPixelShader == 20;
    #if (FRAGMENTSHADER == 20)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * _473.uTexSampleAlpha.y;
    #endif
    bool _1056 = uPixelShader == 21;
    #if (FRAGMENTSHADER == 21)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w + tex2.w;
    canDiscard = true;
    specular = tex2.xyz * (1.0 - tex.w);
    #endif
    bool _1079 = uPixelShader == 22;
    #if (FRAGMENTSHADER == 22)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * tex2.xyz, tex.xyz, vec3(tex.w));
    #endif
    bool _1100 = uPixelShader == 23;
    #if (FRAGMENTSHADER == 23)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w;
    canDiscard = true;
    specular = (tex2.xyz * tex2.w) * _473.uTexSampleAlpha.y;
    #endif
    bool _1122 = uPixelShader == 24;
    #if (FRAGMENTSHADER == 24)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    specular = (tex.xyz * tex.w) * _473.uTexSampleAlpha.x;
    #endif
    bool _1148 = uPixelShader == 25;
    #if (FRAGMENTSHADER == 25)
    highp float glowOpacity = clamp(tex3.w * _473.uTexSampleAlpha.z, 0.0, 1.0);
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w))) * (1.0 - glowOpacity);
    specular = tex3.xyz * glowOpacity;
    #endif
    bool _1184 = uPixelShader == 26;
    #if (FRAGMENTSHADER == 26)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_473.uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_473.uTexSampleAlpha.z, 0.0, 1.0))).xyz;
    discardAlpha = mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_473.uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_473.uTexSampleAlpha.z, 0.0, 1.0))).w;
    canDiscard = true;
    #endif
    bool _1222 = uPixelShader == 27;
    #if (FRAGMENTSHADER == 27)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w)), tex.xyz, vec3(tex.w));
    #endif
    bool _1250 = uPixelShader == 28;
    #if (FRAGMENTSHADER == 28)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_473.uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_473.uTexSampleAlpha.z, 0.0, 1.0))).xyz;
    discardAlpha = mix(mix(tex, tex2WithTextCoord1, vec4(clamp(_473.uTexSampleAlpha.y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(_473.uTexSampleAlpha.z, 0.0, 1.0))).w * tex4WithTextCoord2.w;
    canDiscard = true;
    #endif
    bool _1291 = uPixelShader == 29;
    #if (FRAGMENTSHADER == 29)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    #endif
    bool _1309 = uPixelShader == 30;
    #if (FRAGMENTSHADER == 30)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    discardAlpha = tex.w;
    canDiscard = true;
    #endif
    bool _1347 = uPixelShader == 31;
    #if (FRAGMENTSHADER == 31)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w));
    discardAlpha = tex.w;
    canDiscard = true;
    #endif
    bool _1375 = uPixelShader == 32;
    #if (FRAGMENTSHADER == 32)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    #endif
    bool _1411 = uPixelShader == 33;
    #if (FRAGMENTSHADER == 33)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    discardAlpha = tex.w;
    canDiscard = true;
    #endif
    bool _1425 = uPixelShader == 34;
    #if (FRAGMENTSHADER == 34)
    discardAlpha = tex.w;
    canDiscard = true;
    #endif
    bool _1433 = uPixelShader == 35;
    #if (FRAGMENTSHADER == 35)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * (((tex * tex2) * tex3) * genericParams[0]).xyz;
    discardAlpha = (((tex * tex2) * tex3) * genericParams[0]).w;
    canDiscard = true;
    #endif
    bool _1461 = uPixelShader == 36;
    #if (FRAGMENTSHADER == 36)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    discardAlpha = tex.w * tex2.w;
    canDiscard = true;
    #endif
    int blendMode = _473.PixelShader_UnFogged_IsAffectedByLight_blendMode.w;
    bool _1482 = blendMode == 13;
    if (_1482)
    {
        finalOpacity = discardAlpha * vDiffuseColor.w;
    }
    else
    {
        bool _1492 = blendMode == 1;
        if (_1492)
        {
            finalOpacity = vDiffuseColor.w;
            bool _1501 = canDiscard && (discardAlpha < 0.501960813999176025390625);
            if (_1501)
            {
                discard;
            }
            finalOpacity = vDiffuseColor.w;
        }
        else
        {
            bool _1509 = blendMode == 0;
            if (_1509)
            {
                finalOpacity = vDiffuseColor.w;
            }
            else
            {
                finalOpacity = discardAlpha * vDiffuseColor.w;
            }
        }
    }
    highp vec3 param = matDiffuse;
    highp vec3 param_1 = vNormal;
    bool param_2 = _473.PixelShader_UnFogged_IsAffectedByLight_blendMode.z > 0;
    highp float param_3 = _496.interiorExteriorBlend.x;
    SceneWideParams param_4;
    param_4.uLookAtMat = _535.scene.uLookAtMat;
    param_4.uPMatrix = _535.scene.uPMatrix;
    param_4.uViewUp = _535.scene.uViewUp;
    param_4.uInteriorSunDir = _535.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _535.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _535.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _535.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _535.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _535.scene.extLight.uExteriorDirectColorDir;
    param_4.extLight.adtSpecMult = _535.scene.extLight.adtSpecMult;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _496.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _496.intLight.uInteriorDirectColorAndApplyExteriorLight;
    highp vec3 param_6 = accumLight;
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vec3(0.0), specular, vec3(0.0)), finalOpacity);
    int uUnFogged = _473.PixelShader_UnFogged_IsAffectedByLight_blendMode.y;
    bool _1579 = uUnFogged == 0;
    if (_1579)
    {
        highp vec3 sunDir = mix(_535.scene.uInteriorSunDir, _535.scene.extLight.uExteriorDirectColorDir, vec4(_496.interiorExteriorBlend.x)).xyz;
        PSFog arg;
        arg.densityParams = _535.fogData.densityParams;
        arg.heightPlane = _535.fogData.heightPlane;
        arg.color_and_heightRate = _535.fogData.color_and_heightRate;
        arg.heightDensity_and_endColor = _535.fogData.heightDensity_and_endColor;
        arg.sunAngle_and_sunColor = _535.fogData.sunAngle_and_sunColor;
        arg.heightColor_and_endFogDistance = _535.fogData.heightColor_and_endFogDistance;
        arg.sunPercentage = _535.fogData.sunPercentage;
        highp vec4 param_7 = finalColor;
        highp vec3 param_8 = vPosition;
        highp vec3 param_9 = sunDir;
        int param_10 = _473.PixelShader_UnFogged_IsAffectedByLight_blendMode.w;
        finalColor = makeFog(arg, param_7, param_8, param_9, param_10);
    }
    outputColor = finalColor;
}


#version 300 es

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
} _133;

layout(std140) uniform meshWideBlockVS
{
    ivec4 vertexShader_IsAffectedByLight;
    vec4 color_Transparency;
    mat4 uTextMat[2];
} _230;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _240;

layout(location = 0) in vec3 aPosition;
layout(location = 3) in vec4 boneWeights;
layout(location = 2) in vec4 bones;
layout(location = 1) in vec3 aNormal;
out vec2 vTexCoord2;
out vec2 vTexCoord3;
out vec4 vDiffuseColor;
out vec2 vTexCoord;
layout(location = 4) in vec2 aTexCoord;
layout(location = 5) in vec2 aTexCoord2;
out vec3 vNormal;
out vec3 vPosition;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

float edgeScan(vec3 position, vec3 normal)
{
    float dotProductClamped = clamp(dot(-normalize(position), normal), 0.0, 1.0);
    return clamp(((2.7000000476837158203125 * dotProductClamped) * dotProductClamped) - 0.4000000059604644775390625, 0.0, 1.0);
}

void main()
{
    vec4 modelPoint = vec4(0.0);
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 boneTransformMat = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0));
    mat4 _143 = _133.uBoneMatrixes[bones.x] * boneWeights.x;
    boneTransformMat = mat4(boneTransformMat[0] + _143[0], boneTransformMat[1] + _143[1], boneTransformMat[2] + _143[2], boneTransformMat[3] + _143[3]);
    mat4 _164 = _133.uBoneMatrixes[bones.y] * boneWeights.y;
    boneTransformMat = mat4(boneTransformMat[0] + _164[0], boneTransformMat[1] + _164[1], boneTransformMat[2] + _164[2], boneTransformMat[3] + _164[3]);
    mat4 _185 = _133.uBoneMatrixes[bones.z] * boneWeights.z;
    boneTransformMat = mat4(boneTransformMat[0] + _185[0], boneTransformMat[1] + _185[1], boneTransformMat[2] + _185[2], boneTransformMat[3] + _185[3]);
    mat4 _207 = _133.uBoneMatrixes[bones.w] * boneWeights.w;
    boneTransformMat = mat4(boneTransformMat[0] + _207[0], boneTransformMat[1] + _207[1], boneTransformMat[2] + _207[2], boneTransformMat[3] + _207[3]);
    mat4 placementMat = _133.uPlacementMat;
    vec4 lDiffuseColor = _230.color_Transparency;
    mat4 cameraMatrix = (_240.scene.uLookAtMat * placementMat) * boneTransformMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    mat4 param = _240.scene.uLookAtMat;
    mat4 param_1 = placementMat;
    mat4 param_2 = boneTransformMat;
    mat3 viewModelMatTransposed = (blizzTranspose(param) * blizzTranspose(param_1)) * blizzTranspose(param_2);
    vec3 normal = normalize(viewModelMatTransposed * aNormal);
    vec4 combinedColor = clamp(lDiffuseColor, vec4(0.0), vec4(1.0));
    vec4 combinedColorHalved = combinedColor * 0.5;
    vec3 param_3 = cameraPoint.xyz;
    vec3 param_4 = normal;
    vec2 envCoord = posToTexCoord(param_3, param_4);
    vec3 param_5 = cameraPoint.xyz;
    vec3 param_6 = normal;
    float edgeScanVal = edgeScan(param_5, param_6);
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vec2(0.0);
    int uVertexShader = _230.vertexShader_IsAffectedByLight.x;
    bool _305 = uVertexShader == 0;
    #if (VERTEXSHADER == 0)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _332 = uVertexShader == 1;
    #if (VERTEXSHADER == 1)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    #endif
    bool _347 = uVertexShader == 2;
    #if (VERTEXSHADER == 2)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _379 = uVertexShader == 3;
    #if (VERTEXSHADER == 3)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    #endif
    bool _403 = uVertexShader == 4;
    #if (VERTEXSHADER == 4)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _427 = uVertexShader == 5;
    #if (VERTEXSHADER == 5)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = envCoord;
    #endif
    bool _444 = uVertexShader == 6;
    #if (VERTEXSHADER == 6)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _476 = uVertexShader == 7;
    #if (VERTEXSHADER == 7)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _507 = uVertexShader == 8;
    #if (VERTEXSHADER == 8)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _546 = uVertexShader == 9;
    #if (VERTEXSHADER == 9)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _571 = uVertexShader == 10;
    #if (VERTEXSHADER == 10)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _594 = uVertexShader == 11;
    #if (VERTEXSHADER == 11)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _626 = uVertexShader == 12;
    #if (VERTEXSHADER == 12)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    bool _659 = uVertexShader == 13;
    #if (VERTEXSHADER == 13)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = envCoord;
    #endif
    bool _677 = uVertexShader == 14;
    #if (VERTEXSHADER == 14)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _716 = uVertexShader == 15;
    #if (VERTEXSHADER == 15)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = vTexCoord3;
    #endif
    bool _748 = uVertexShader == 16;
    #if (VERTEXSHADER == 16)
    vec4 in_col0 = vec4(1.0);
    vDiffuseColor = vec4((in_col0.xyz * 0.5).x, (in_col0.xyz * 0.5).y, (in_col0.xyz * 0.5).z, in_col0.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vTexCoord3;
    #endif
    bool _780 = uVertexShader == 17;
    #if (VERTEXSHADER == 17)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    bool _803 = uVertexShader == 18;
    #if (VERTEXSHADER == 18)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    gl_Position = _240.scene.uPMatrix * cameraPoint;
    vNormal = normal;
    vPosition = cameraPoint.xyz;
}


#version 300 es
precision mediump float;
precision highp int;

layout(std140) uniform meshWideBlockPS
{
    highp float gauss_offsets[5];
    highp float gauss_weights[5];
    highp vec2 uResolution;
} _34;

uniform highp sampler2D u_sampler;
uniform highp sampler2D u_depth;

in highp vec2 v_texcoord;
layout(location = 0) out highp vec4 outputColor;

void main()
{
    highp float FXAA_SPAN_MAX = 8.0;
    highp float FXAA_REDUCE_MUL = 0.125;
    highp float FXAA_REDUCE_MIN = 0.0078125;
    highp vec3 rgbNW = texture(u_sampler, v_texcoord + (vec2(-1.0) / _34.uResolution)).xyz;
    highp vec3 rgbNE = texture(u_sampler, v_texcoord + (vec2(1.0, -1.0) / _34.uResolution)).xyz;
    highp vec3 rgbSW = texture(u_sampler, v_texcoord + (vec2(-1.0, 1.0) / _34.uResolution)).xyz;
    highp vec3 rgbSE = texture(u_sampler, v_texcoord + (vec2(1.0) / _34.uResolution)).xyz;
    highp vec3 rgbM = texture(u_sampler, v_texcoord).xyz;
    highp vec3 luma = vec3(0.2989999949932098388671875, 0.58700001239776611328125, 0.114000000059604644775390625);
    highp float lumaNW = dot(rgbNW, luma);
    highp float lumaNE = dot(rgbNE, luma);
    highp float lumaSW = dot(rgbSW, luma);
    highp float lumaSE = dot(rgbSE, luma);
    highp float lumaM = dot(rgbM, luma);
    highp float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    highp float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
    highp vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y = (lumaNW + lumaSW) - (lumaNE + lumaSE);
    highp float dirReduce = max((((lumaNW + lumaNE) + lumaSW) + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
    highp float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) / _34.uResolution;
    highp vec3 rgbA = (texture(u_sampler, v_texcoord + (dir * (-0.16666667163372039794921875))).xyz + texture(u_sampler, v_texcoord + (dir * 0.16666667163372039794921875)).xyz) * 0.5;
    highp vec3 rgbB = (rgbA * 0.5) + ((texture(u_sampler, v_texcoord + (dir * (-0.5))).xyz + texture(u_sampler, v_texcoord + (dir * 0.5)).xyz) * 0.25);
    highp float lumaB = dot(rgbB, luma);
    bool _240 = (lumaB < lumaMin) || (lumaB > lumaMax);
    if (_240)
    {
        outputColor = vec4(rgbA.x, rgbA.y, rgbA.z, outputColor.w);
    }
    else
    {
        outputColor = vec4(rgbB.x, rgbB.y, rgbB.z, outputColor.w);
    }
}


#version 300 es

layout(location = 0) in vec4 a_position;
out vec2 v_texcoord;

void main()
{
    gl_Position = a_position;
    v_texcoord = (a_position.xy * 0.5) + vec2(0.5);
}


#version 300 es
precision mediump float;
precision highp int;

struct PSFog
{
    highp vec4 densityParams;
    highp vec4 heightPlane;
    highp vec4 color_and_heightRate;
    highp vec4 heightDensity_and_endColor;
    highp vec4 sunAngle_and_sunColor;
    highp vec4 heightColor_and_endFogDistance;
    highp vec4 sunPercentage;
};

const vec3 _37[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _44[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct SceneExteriorLight
{
    highp vec4 uExteriorAmbientColor;
    highp vec4 uExteriorHorizontAmbientColor;
    highp vec4 uExteriorGroundAmbientColor;
    highp vec4 uExteriorDirectColor;
    highp vec4 uExteriorDirectColorDir;
    highp vec4 adtSpecMult;
};

struct SceneWideParams
{
    highp mat4 uLookAtMat;
    highp mat4 uPMatrix;
    highp vec4 uViewUp;
    highp vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

layout(std140) uniform meshWideBlockPS
{
    highp vec4 uAlphaTestScalev;
    ivec4 uPixelShaderv;
    highp vec4 uTextureTranslate;
} _256;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _304;

uniform highp sampler2D uTexture;

in highp vec2 vTexcoord0;
in highp vec4 vColor;
in highp vec3 vPosition;
layout(location = 0) out highp vec4 outputColor;

highp vec3 validateFogColor(highp vec3 fogColor, int blendMode)
{
    return mix(fogColor, _37[blendMode], vec3(_44[blendMode]));
}

highp vec4 makeFog(PSFog fogData, highp vec4 final, highp vec3 vertexInViewSpace, highp vec3 sunDirInViewSpace, int blendMode)
{
    highp vec4 l_densityParams = fogData.densityParams;
    highp vec4 l_heightPlane = fogData.heightPlane;
    highp vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    highp vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    highp float start = l_densityParams.x;
    highp float end = l_densityParams.y;
    highp float density = l_densityParams.z;
    highp float bias = l_densityParams.w;
    highp float vLength = length(vertexInViewSpace);
    highp float z = vLength - bias;
    highp float expMax = max(0.0, z - start);
    highp float expFog = 1.0 / exp(expMax * density);
    highp float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    highp float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    highp float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    highp float finalFog = mix(expFog, expFogHeight, heightFog);
    highp float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    highp float alpha = 1.0;
    bool _139 = blendMode == 13;
    if (_139)
    {
        alpha = min(finalFog, endFadeFog);
    }
    highp vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    highp vec3 endColor = validateFogColor(param, param_1);
    highp vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    highp float end2 = vLength / l_heightColor_and_endFogDistance.w;
    highp float end2_cube = end2 * (end2 * end2);
    highp vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    highp vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    highp vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    highp vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    highp float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    highp vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    highp vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _218 = nDotSun > 0.0;
    if (_218)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final.xyz, vec3(min(finalFog, endFadeFog)));
    return vec4(fogFinal, final.w * alpha);
}

void main()
{
    highp vec2 textCoordScale = _256.uAlphaTestScalev.yz;
    highp vec2 texcoord = (vTexcoord0 * textCoordScale) + _256.uTextureTranslate.xy;
    highp vec4 tex = texture(uTexture, texcoord);
    highp vec4 finalColor = vec4(vColor.xyz * tex.xyz, tex.w * vColor.w);
    highp vec3 sunDir = _304.scene.extLight.uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _304.fogData.densityParams;
    arg.heightPlane = _304.fogData.heightPlane;
    arg.color_and_heightRate = _304.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _304.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _304.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _304.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _304.fogData.sunPercentage;
    highp vec4 param = finalColor;
    highp vec3 param_1 = vPosition;
    highp vec3 param_2 = sunDir;
    int param_3 = _256.uPixelShaderv.y;
    finalColor = makeFog(arg, param, param_1, param_2, param_3);
    outputColor = finalColor;
}


#version 300 es

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _37;

layout(location = 0) in vec3 aPosition;
out vec4 vColor;
layout(location = 1) in vec4 aColor;
out vec2 vTexcoord0;
layout(location = 2) in vec2 aTexcoord0;
out vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vec4 vertexViewSpace = _37.scene.uLookAtMat * aPositionVec4;
    vPosition = vertexViewSpace.xyz;
    gl_Position = _37.scene.uPMatrix * vertexViewSpace;
}


#version 300 es
precision mediump float;
precision highp int;

layout(location = 0) out highp vec4 outputColor;
in highp vec4 vColor;

void main()
{
    outputColor = vec4(vColor.xyz, vColor.w);
}


#version 300 es

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _26;

layout(std140) uniform meshWideBlockVS
{
    vec4 skyColor[6];
} _67;

layout(location = 0) in vec4 aPosition;
out vec4 vColor;

void main()
{
    vec3 inputPos = aPosition.xyz;
    inputPos *= 33.33300018310546875;
    vec4 cameraPos = _26.scene.uLookAtMat * vec4(inputPos, 1.0);
    vec3 _46 = cameraPos.xyz - _26.scene.uLookAtMat[3].xyz;
    cameraPos = vec4(_46.x, _46.y, _46.z, cameraPos.w);
    cameraPos.z = cameraPos.z;
    vec4 vertPosInNDC = _26.scene.uPMatrix * cameraPos;
    vColor = _67.skyColor[int(aPosition.w)];
    gl_Position = _26.scene.uPMatrix * cameraPos;
}


#version 300 es
precision mediump float;
precision highp int;

struct PSFog
{
    highp vec4 densityParams;
    highp vec4 heightPlane;
    highp vec4 color_and_heightRate;
    highp vec4 heightDensity_and_endColor;
    highp vec4 sunAngle_and_sunColor;
    highp vec4 heightColor_and_endFogDistance;
    highp vec4 sunPercentage;
};

const vec3 _37[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _44[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

struct SceneExteriorLight
{
    highp vec4 uExteriorAmbientColor;
    highp vec4 uExteriorHorizontAmbientColor;
    highp vec4 uExteriorGroundAmbientColor;
    highp vec4 uExteriorDirectColor;
    highp vec4 uExteriorDirectColorDir;
    highp vec4 adtSpecMult;
};

struct SceneWideParams
{
    highp mat4 uLookAtMat;
    highp mat4 uPMatrix;
    highp vec4 uViewUp;
    highp vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

layout(std140) uniform meshWideBlockPS
{
    highp vec4 color;
} _253;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _277;

uniform highp sampler2D uTexture;

in highp vec2 vTextCoords;
in highp vec3 vPosition;
layout(location = 0) out highp vec4 outputColor;

highp vec3 validateFogColor(highp vec3 fogColor, int blendMode)
{
    return mix(fogColor, _37[blendMode], vec3(_44[blendMode]));
}

highp vec4 makeFog(PSFog fogData, highp vec4 final, highp vec3 vertexInViewSpace, highp vec3 sunDirInViewSpace, int blendMode)
{
    highp vec4 l_densityParams = fogData.densityParams;
    highp vec4 l_heightPlane = fogData.heightPlane;
    highp vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    highp vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    highp float start = l_densityParams.x;
    highp float end = l_densityParams.y;
    highp float density = l_densityParams.z;
    highp float bias = l_densityParams.w;
    highp float vLength = length(vertexInViewSpace);
    highp float z = vLength - bias;
    highp float expMax = max(0.0, z - start);
    highp float expFog = 1.0 / exp(expMax * density);
    highp float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    highp float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    highp float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    highp float finalFog = mix(expFog, expFogHeight, heightFog);
    highp float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    highp float alpha = 1.0;
    bool _139 = blendMode == 13;
    if (_139)
    {
        alpha = min(finalFog, endFadeFog);
    }
    highp vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    highp vec3 endColor = validateFogColor(param, param_1);
    highp vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    highp float end2 = vLength / l_heightColor_and_endFogDistance.w;
    highp float end2_cube = end2 * (end2 * end2);
    highp vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    highp vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    highp vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    highp vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    highp float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    highp vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    highp vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _218 = nDotSun > 0.0;
    if (_218)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final.xyz, vec3(min(finalFog, endFadeFog)));
    return vec4(fogFinal, final.w * alpha);
}

void main()
{
    highp vec3 finalColor = _253.color.xyz + texture(uTexture, vTextCoords).xyz;
    highp vec3 sunDir = _277.scene.extLight.uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _277.fogData.densityParams;
    arg.heightPlane = _277.fogData.heightPlane;
    arg.color_and_heightRate = _277.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _277.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _277.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _277.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _277.fogData.sunPercentage;
    highp vec4 param = vec4(finalColor, 1.0);
    highp vec3 param_1 = vPosition;
    highp vec3 param_2 = sunDir;
    int param_3 = 2;
    finalColor = makeFog(arg, param, param_1, param_2, param_3).xyz;
    outputColor = vec4(finalColor, 0.699999988079071044921875);
}


#version 300 es

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _28;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _36;

layout(location = 0) in vec4 aPositionTransp;
out vec2 vTextCoords;
out vec3 vPosition;
layout(location = 1) in vec2 aTexCoord;

void main()
{
    vec4 aPositionVec4 = vec4(aPositionTransp.xyz, 1.0);
    mat4 cameraMatrix = _28.scene.uLookAtMat * _36.uPlacementMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    vTextCoords = aPositionVec4.xy * 0.02999999932944774627685546875;
    gl_Position = _28.scene.uPMatrix * cameraPoint;
    vPosition = cameraPoint.xyz;
}


#version 300 es
precision mediump float;
precision highp int;

struct SceneExteriorLight
{
    highp vec4 uExteriorAmbientColor;
    highp vec4 uExteriorHorizontAmbientColor;
    highp vec4 uExteriorGroundAmbientColor;
    highp vec4 uExteriorDirectColor;
    highp vec4 uExteriorDirectColorDir;
    highp vec4 adtSpecMult;
};

struct SceneWideParams
{
    highp mat4 uLookAtMat;
    highp mat4 uPMatrix;
    highp vec4 uViewUp;
    highp vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    highp vec4 uInteriorAmbientColorAndApplyInteriorLight;
    highp vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    highp vec4 densityParams;
    highp vec4 heightPlane;
    highp vec4 color_and_heightRate;
    highp vec4 heightDensity_and_endColor;
    highp vec4 sunAngle_and_sunColor;
    highp vec4 heightColor_and_endFogDistance;
    highp vec4 sunPercentage;
};

const vec3 _221[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _228[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

layout(std140) uniform meshWideBlockPS
{
    highp vec4 values0;
    highp vec4 values1;
    highp vec4 values2;
    highp vec4 values3;
    highp vec4 values4;
    highp vec4 baseColor;
} _445;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _709;

layout(std140) uniform modelWideBlockVS
{
    highp mat4 uPlacementMat;
    highp mat4 uBoneMatrixes[220];
} _818;

uniform highp sampler2D uNormalTex;
uniform highp sampler2D uNoise;
uniform highp sampler2D uWhiteWater;
uniform highp sampler2D uMask;

in highp vec2 vTexCoord2_animated;
in highp vec3 vPosition;
in highp vec3 vNormal;
in highp vec2 vTexCoord;
layout(location = 0) out highp vec4 outputColor;
in highp vec2 vTexCoord2;

highp vec3 PerturbNormal(highp vec3 surf_pos, highp vec3 surf_norm)
{
    highp vec2 dBdUV = ((texture(uNormalTex, vTexCoord2_animated).xy * 2.0) - vec2(1.0)) * (_445.values3.x * 100.0);
    highp vec2 duv1 = dFdx(vTexCoord2_animated);
    highp vec2 duv2 = dFdy(vTexCoord2_animated);
    highp vec3 vSigmaS = dFdx(surf_pos);
    highp vec3 vSigmaT = dFdy(surf_pos);
    highp vec3 vN = surf_norm;
    highp vec3 vR1 = cross(vSigmaT, vN);
    highp vec3 vR2 = cross(vN, vSigmaS);
    highp float fDet = dot(vSigmaS, vR1);
    highp float dBs = (dBdUV.x * duv1.x) + (dBdUV.y * duv1.y);
    highp float dBt = (dBdUV.x * duv2.x) + (dBdUV.y * duv2.y);
    highp vec3 vSurfGrad = ((vR1 * dBs) + (vR2 * dBt)) * sign(fDet);
    return normalize((vN * abs(fDet)) - vSurfGrad);
}

highp vec3 calcLight(highp vec3 matDiffuse, highp vec3 vNormal_1, bool applyLight, highp float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, highp vec3 accumLight, highp vec3 precomputedLight, highp vec3 specular, highp vec3 emissive)
{
    highp vec3 localDiffuse = accumLight;
    bool _57 = !applyLight;
    if (_57)
    {
        return matDiffuse;
    }
    highp vec3 lDiffuse = vec3(0.0);
    highp vec3 normalizedN = normalize(vNormal_1);
    bool _73 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    highp vec3 currColor;
    if (_73)
    {
        highp float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        highp float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        highp vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        highp vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        highp vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _110 = nDotUp >= 0.0;
        if (_110)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        highp vec3 skyColor = currColor * 1.10000002384185791015625;
        highp vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _150 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_150)
    {
        highp float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        highp vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        highp vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _174 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_174)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    highp vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    highp vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    highp vec3 specTerm = specular;
    highp vec3 emTerm = emissive;
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

highp vec3 validateFogColor(highp vec3 fogColor, int blendMode)
{
    return mix(fogColor, _221[blendMode], vec3(_228[blendMode]));
}

highp vec4 makeFog(PSFog fogData, highp vec4 final, highp vec3 vertexInViewSpace, highp vec3 sunDirInViewSpace, int blendMode)
{
    highp vec4 l_densityParams = fogData.densityParams;
    highp vec4 l_heightPlane = fogData.heightPlane;
    highp vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    highp vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    highp float start = l_densityParams.x;
    highp float end = l_densityParams.y;
    highp float density = l_densityParams.z;
    highp float bias = l_densityParams.w;
    highp float vLength = length(vertexInViewSpace);
    highp float z = vLength - bias;
    highp float expMax = max(0.0, z - start);
    highp float expFog = 1.0 / exp(expMax * density);
    highp float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    highp float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    highp float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    highp float finalFog = mix(expFog, expFogHeight, heightFog);
    highp float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    highp float alpha = 1.0;
    bool _316 = blendMode == 13;
    if (_316)
    {
        alpha = min(finalFog, endFadeFog);
    }
    highp vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    highp vec3 endColor = validateFogColor(param, param_1);
    highp vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    highp float end2 = vLength / l_heightColor_and_endFogDistance.w;
    highp float end2_cube = end2 * (end2 * end2);
    highp vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    highp vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    highp vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    highp vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    highp float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    highp vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    highp vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _394 = nDotSun > 0.0;
    if (_394)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final.xyz, vec3(min(finalFog, endFadeFog)));
    return vec4(fogFinal, final.w * alpha);
}

void main()
{
    highp vec3 param = vPosition;
    highp vec3 param_1 = normalize(vNormal);
    highp vec3 perturbedNormal = PerturbNormal(param, param_1);
    highp vec2 vTexCoordNorm = vTexCoord / vec2(_445.values1.x);
    highp float noise0 = texture(uNoise, vec2(vTexCoordNorm.x - _445.values1.z, (vTexCoordNorm.y - _445.values1.z) - _445.values2.z)).x;
    highp float _noise1 = texture(uNoise, vec2((vTexCoordNorm.x - _445.values1.z) + 0.4180000126361846923828125, ((vTexCoordNorm.y + 0.3549999892711639404296875) + _445.values1.z) - _445.values2.z)).x;
    highp float _noise2 = texture(uNoise, vec2((vTexCoordNorm.x + _445.values1.z) + 0.8650000095367431640625, ((vTexCoordNorm.y + 0.1480000019073486328125) - _445.values1.z) - _445.values2.z)).x;
    highp float _noise3 = texture(uNoise, vec2((vTexCoordNorm.x + _445.values1.z) + 0.65100002288818359375, ((vTexCoordNorm.y + 0.75199997425079345703125) + _445.values1.z) - _445.values2.z)).x;
    highp float noise_avr = abs(((noise0 + _noise1) + _noise2) + _noise3) * 0.25;
    highp float noiseFinal = clamp(exp((_445.values0.x * log2(noise_avr)) * 2.2000000476837158203125) * _445.values0.y, 0.0, 1.0);
    highp vec4 whiteWater_val = texture(uWhiteWater, vTexCoord2_animated);
    highp vec4 mask_val_0 = texture(uMask, vTexCoord);
    highp vec4 mask_val_1 = texture(uMask, vec2(vTexCoord.x, vTexCoord.y + _445.values3.z));
    highp float mix_alpha = clamp((((((whiteWater_val.w * noiseFinal) - (mask_val_1.y * mask_val_0.x)) * 2.0) + _445.values0.z) * ((_445.values0.w * 2.0) + 1.0)) - _445.values0.w, 0.0, 1.0);
    highp vec4 whiteWater_val_baseColor_mix = mix(_445.baseColor, whiteWater_val, vec4(mix_alpha));
    highp vec3 param_2 = whiteWater_val_baseColor_mix.xyz;
    highp vec3 param_3 = perturbedNormal;
    bool param_4 = true;
    highp float param_5 = 0.0;
    SceneWideParams param_6;
    param_6.uLookAtMat = _709.scene.uLookAtMat;
    param_6.uPMatrix = _709.scene.uPMatrix;
    param_6.uViewUp = _709.scene.uViewUp;
    param_6.uInteriorSunDir = _709.scene.uInteriorSunDir;
    param_6.extLight.uExteriorAmbientColor = _709.scene.extLight.uExteriorAmbientColor;
    param_6.extLight.uExteriorHorizontAmbientColor = _709.scene.extLight.uExteriorHorizontAmbientColor;
    param_6.extLight.uExteriorGroundAmbientColor = _709.scene.extLight.uExteriorGroundAmbientColor;
    param_6.extLight.uExteriorDirectColor = _709.scene.extLight.uExteriorDirectColor;
    param_6.extLight.uExteriorDirectColorDir = _709.scene.extLight.uExteriorDirectColorDir;
    param_6.extLight.adtSpecMult = _709.scene.extLight.adtSpecMult;
    InteriorLightParam param_7 = InteriorLightParam(vec4(0.0), vec4(0.0, 0.0, 0.0, 1.0));
    highp vec3 param_8 = vec3(0.0);
    highp vec3 colorAfterLight = calcLight(param_2, param_3, param_4, param_5, param_6, param_7, param_8, vec3(0.0), vec3(0.0), vec3(0.0));
    highp float w_clamped = clamp((1.0 - mask_val_0.w) * _445.values1.w, 0.0, 1.0);
    highp float w_alpha_combined = clamp(w_clamped + mix_alpha, 0.0, 1.0);
    highp vec4 finalColor = vec4(mix(colorAfterLight, whiteWater_val_baseColor_mix.xyz, vec3(_445.values3.w)), w_alpha_combined);
    highp vec3 sunDir = _709.scene.extLight.uExteriorDirectColorDir.xyz;
    PSFog arg;
    arg.densityParams = _709.fogData.densityParams;
    arg.heightPlane = _709.fogData.heightPlane;
    arg.color_and_heightRate = _709.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _709.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _709.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _709.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _709.fogData.sunPercentage;
    highp vec4 param_9 = finalColor;
    highp vec3 param_10 = vPosition;
    highp vec3 param_11 = sunDir;
    int param_12 = 0;
    finalColor = makeFog(arg, param_9, param_10, param_11, param_12);
    outputColor = finalColor;
}


#version 300 es

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform meshWideBlockVS
{
    vec4 bumpScale;
    mat4 uTextMat[2];
} _55;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
} _104;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _199;

uniform highp sampler2D uBumpTexture;

layout(location = 5) in vec2 aTexCoord2;
layout(location = 1) in vec3 aNormal;
layout(location = 0) in vec3 aPosition;
layout(location = 3) in vec4 boneWeights;
layout(location = 2) in vec4 bones;
out vec3 vNormal;
out vec3 vPosition;
out vec2 vTexCoord;
layout(location = 4) in vec2 aTexCoord;
out vec2 vTexCoord2_animated;
out vec2 vTexCoord2;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

void main()
{
    vec2 texCoord2 = (_55.uTextMat[0] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vec4 bumpValue = textureLod(uBumpTexture, texCoord2, 0.0);
    vec3 pos = ((aNormal * _55.bumpScale.x) * bumpValue.z) + aPosition;
    mat4 boneTransformMat = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0));
    mat4 _113 = _104.uBoneMatrixes[bones.x] * boneWeights.x;
    boneTransformMat = mat4(boneTransformMat[0] + _113[0], boneTransformMat[1] + _113[1], boneTransformMat[2] + _113[2], boneTransformMat[3] + _113[3]);
    mat4 _135 = _104.uBoneMatrixes[bones.y] * boneWeights.y;
    boneTransformMat = mat4(boneTransformMat[0] + _135[0], boneTransformMat[1] + _135[1], boneTransformMat[2] + _135[2], boneTransformMat[3] + _135[3]);
    mat4 _156 = _104.uBoneMatrixes[bones.z] * boneWeights.z;
    boneTransformMat = mat4(boneTransformMat[0] + _156[0], boneTransformMat[1] + _156[1], boneTransformMat[2] + _156[2], boneTransformMat[3] + _156[3]);
    mat4 _178 = _104.uBoneMatrixes[bones.w] * boneWeights.w;
    boneTransformMat = mat4(boneTransformMat[0] + _178[0], boneTransformMat[1] + _178[1], boneTransformMat[2] + _178[2], boneTransformMat[3] + _178[3]);
    mat4 cameraMatrix = (_199.scene.uLookAtMat * _104.uPlacementMat) * boneTransformMat;
    vec4 cameraPoint = cameraMatrix * vec4(pos, 1.0);
    mat4 param = _199.scene.uLookAtMat;
    mat4 param_1 = _104.uPlacementMat;
    mat4 param_2 = boneTransformMat;
    mat3 viewModelMatTransposed = (blizzTranspose(param) * blizzTranspose(param_1)) * blizzTranspose(param_2);
    vNormal = ((_199.scene.uLookAtMat * _104.uPlacementMat) * vec4(aNormal, 0.0)).xyz;
    vPosition = pos;
    vTexCoord = aTexCoord;
    vTexCoord2_animated = texCoord2;
    vTexCoord2 = aTexCoord2;
    gl_Position = _199.scene.uPMatrix * cameraPoint;
}


#version 300 es
precision mediump float;
precision highp int;

struct SceneExteriorLight
{
    highp vec4 uExteriorAmbientColor;
    highp vec4 uExteriorHorizontAmbientColor;
    highp vec4 uExteriorGroundAmbientColor;
    highp vec4 uExteriorDirectColor;
    highp vec4 uExteriorDirectColorDir;
    highp vec4 adtSpecMult;
};

struct SceneWideParams
{
    highp mat4 uLookAtMat;
    highp mat4 uPMatrix;
    highp vec4 uViewUp;
    highp vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    highp vec4 uInteriorAmbientColorAndApplyInteriorLight;
    highp vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct PSFog
{
    highp vec4 densityParams;
    highp vec4 heightPlane;
    highp vec4 color_and_heightRate;
    highp vec4 heightDensity_and_endColor;
    highp vec4 sunAngle_and_sunColor;
    highp vec4 heightColor_and_endFogDistance;
    highp vec4 sunPercentage;
};

const vec3 _232[14] = vec3[](vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec3(1.0), vec3(0.5), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.5), vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));
const float _239[14] = float[](0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0);

layout(std140) uniform modelWideBlockPS
{
    InteriorLightParam intLight;
} _525;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _537;

layout(std140) uniform meshWideBlockPS
{
    ivec4 UseLitColor_EnableAlpha_PixelShader_BlendMode;
    highp vec4 FogColor_AlphaTest;
} _657;

uniform highp sampler2D uTexture;
uniform highp sampler2D uTexture2;
uniform highp sampler2D uTexture3;
uniform highp sampler2D uTexture6;
uniform highp sampler2D uTexture4;
uniform highp sampler2D uTexture5;
uniform highp sampler2D uTexture7;
uniform highp sampler2D uTexture8;
uniform highp sampler2D uTexture9;

in highp vec3 vNormal;
in highp vec4 vColor;
in highp vec4 vPosition;
in highp vec2 vTexCoord;
in highp vec2 vTexCoord2;
in highp vec2 vTexCoord3;
in highp vec4 vColor2;
in highp vec4 vColorSecond;
in highp vec2 vTexCoord4;
layout(location = 0) out highp vec4 outputColor;

highp vec3 Slerp(highp vec3 p0, highp vec3 p1, highp float t)
{
    highp float dotp = dot(normalize(p0), normalize(p1));
    bool _479 = (dotp > 0.99989998340606689453125) || (dotp < (-0.99989998340606689453125));
    if (_479)
    {
        bool _483 = t <= 0.5;
        if (_483)
        {
            return p0;
        }
        return p1;
    }
    highp float theta = acos(dotp);
    highp vec3 P = ((p0 * sin((1.0 - t) * theta)) + (p1 * sin(t * theta))) / vec3(sin(theta));
    return P;
}

highp vec3 calcSpec(highp float texAlpha)
{
    highp vec3 normal = normalize(vNormal);
    highp vec3 sunDir = vec3(0.0);
    highp vec3 sunColor = vec3(0.0);
    bool _529 = _525.intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    if (_529)
    {
        sunDir = -_537.scene.extLight.uExteriorDirectColorDir.xyz;
        sunColor = _537.scene.extLight.uExteriorDirectColor.xyz;
    }
    bool _548 = _525.intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_548)
    {
        sunDir = -_537.scene.uInteriorSunDir.xyz;
        sunColor = _525.intLight.uInteriorDirectColorAndApplyExteriorLight.xyz;
        bool _560 = _525.intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_560)
        {
            highp vec3 param = sunDir;
            highp vec3 param_1 = -_537.scene.extLight.uExteriorDirectColorDir.xyz;
            highp float param_2 = vColor.w;
            sunDir = Slerp(param, param_1, param_2);
            sunColor = mix(sunColor, _537.scene.extLight.uExteriorDirectColor.xyz, vec3(vColor.w));
        }
    }
    highp vec3 t849 = normalize(sunDir + normalize(-vPosition.xyz));
    highp float dirAtten_956 = clamp(dot(normal, sunDir), 0.0, 1.0);
    highp float spec = 1.25 * pow(clamp(dot(normal, t849), 0.0, 1.0), 8.0);
    highp vec3 specTerm = ((vec3(mix(pow(1.0 - clamp(dot(sunDir, t849), 0.0, 1.0), 5.0), 1.0, texAlpha)) * spec) * sunColor) * dirAtten_956;
    highp float distFade = 1.0;
    specTerm *= distFade;
    return specTerm;
}

highp vec2 posToTexCoord(highp vec3 cameraPoint, highp vec3 normal)
{
    highp vec3 normPos_495 = normalize(cameraPoint);
    highp vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    highp vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

highp vec3 calcLight(highp vec3 matDiffuse, highp vec3 vNormal_1, bool applyLight, highp float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, highp vec3 accumLight, highp vec3 precomputedLight, highp vec3 specular, highp vec3 emissive)
{
    highp vec3 localDiffuse = accumLight;
    bool _68 = !applyLight;
    if (_68)
    {
        return matDiffuse;
    }
    highp vec3 lDiffuse = vec3(0.0);
    highp vec3 normalizedN = normalize(vNormal_1);
    bool _84 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
    highp vec3 currColor;
    if (_84)
    {
        highp float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        highp float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        highp vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        highp vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        highp vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        bool _121 = nDotUp >= 0.0;
        if (_121)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        highp vec3 skyColor = currColor * 1.10000002384185791015625;
        highp vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    bool _161 = intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0;
    if (_161)
    {
        highp float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        highp vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        highp vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        bool _185 = intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0;
        if (_185)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    highp vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    highp vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    highp vec3 specTerm = specular;
    highp vec3 emTerm = emissive;
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

highp vec3 validateFogColor(highp vec3 fogColor, int blendMode)
{
    return mix(fogColor, _232[blendMode], vec3(_239[blendMode]));
}

highp vec4 makeFog(PSFog fogData, highp vec4 final, highp vec3 vertexInViewSpace, highp vec3 sunDirInViewSpace, int blendMode)
{
    highp vec4 l_densityParams = fogData.densityParams;
    highp vec4 l_heightPlane = fogData.heightPlane;
    highp vec4 l_color_and_heightRate = fogData.color_and_heightRate;
    highp vec4 l_heightDensity_and_endColor = fogData.heightDensity_and_endColor;
    highp float start = l_densityParams.x;
    highp float end = l_densityParams.y;
    highp float density = l_densityParams.z;
    highp float bias = l_densityParams.w;
    highp float vLength = length(vertexInViewSpace);
    highp float z = vLength - bias;
    highp float expMax = max(0.0, z - start);
    highp float expFog = 1.0 / exp(expMax * density);
    highp float expFogHeight = 1.0 / exp(expMax * l_heightDensity_and_endColor.x);
    highp float height = dot(l_heightPlane.xyz, vertexInViewSpace) + l_heightPlane.w;
    highp float heightFog = clamp(height * l_color_and_heightRate.w, 0.0, 1.0);
    highp float finalFog = mix(expFog, expFogHeight, heightFog);
    highp float endFadeFog = clamp(1.4285714626312255859375 * (1.0 - (vLength / end)), 0.0, 1.0);
    highp float alpha = 1.0;
    bool _327 = blendMode == 13;
    if (_327)
    {
        alpha = min(finalFog, endFadeFog);
    }
    highp vec3 param = l_heightDensity_and_endColor.yzw;
    int param_1 = blendMode;
    highp vec3 endColor = validateFogColor(param, param_1);
    highp vec4 l_heightColor_and_endFogDistance = fogData.heightColor_and_endFogDistance;
    highp float end2 = vLength / l_heightColor_and_endFogDistance.w;
    highp float end2_cube = end2 * (end2 * end2);
    highp vec3 param_2 = l_heightColor_and_endFogDistance.xyz;
    int param_3 = blendMode;
    highp vec3 heightColor = mix(validateFogColor(param_2, param_3), endColor, vec3(clamp(end2, 0.0, 1.0)));
    highp vec3 param_4 = l_color_and_heightRate.xyz;
    int param_5 = blendMode;
    highp vec3 fogFinal = mix(validateFogColor(param_4, param_5), endColor, vec3(clamp(end2_cube, 0.0, 1.0)));
    fogFinal = mix(fogFinal, heightColor, vec3(heightFog));
    highp float nDotSun = dot(normalize(vertexInViewSpace), sunDirInViewSpace);
    highp vec3 param_6 = fogData.sunAngle_and_sunColor.yzw;
    int param_7 = blendMode;
    highp vec3 sunColor = mix(fogFinal, validateFogColor(param_6, param_7), vec3(fogData.sunPercentage.x));
    nDotSun = clamp(nDotSun - fogData.sunAngle_and_sunColor.x, 0.0, 1.0);
    bool _405 = nDotSun > 0.0;
    if (_405)
    {
        nDotSun = (nDotSun * nDotSun) * nDotSun;
        fogFinal = mix(fogFinal, sunColor, vec3(nDotSun));
    }
    fogFinal = mix(fogFinal, final.xyz, vec3(min(finalFog, endFadeFog)));
    return vec4(fogFinal, final.w * alpha);
}

void main()
{
    highp vec4 tex = texture(uTexture, vTexCoord);
    highp vec4 tex2 = texture(uTexture2, vTexCoord2);
    highp vec4 tex3 = texture(uTexture3, vTexCoord3);
    bool _661 = _657.UseLitColor_EnableAlpha_PixelShader_BlendMode.y == 1;
    if (_661)
    {
        bool _668 = (tex.w - 0.501960813999176025390625) < 0.0;
        if (_668)
        {
            discard;
        }
    }
    int uPixelShader = _657.UseLitColor_EnableAlpha_PixelShader_BlendMode.z;
    highp vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    highp vec3 matDiffuse = vec3(0.0);
    highp vec3 spec = vec3(0.0);
    highp vec3 emissive = vec3(0.0);
    highp float finalOpacity = 0.0;
    highp float distFade = 1.0;
    bool _684 = uPixelShader == (-1);
    #if (FRAGMENTSHADER == (-1))
    matDiffuse = tex.xyz * tex2.xyz;
    finalOpacity = tex.w;
    #endif
    bool _696 = uPixelShader == 0;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = tex.xyz;
    finalOpacity = tex.w;
    #endif
    bool _705 = uPixelShader == 1;
    #if (FRAGMENTSHADER == 1)
    matDiffuse = tex.xyz;
    highp float param = tex.w;
    spec = calcSpec(param);
    finalOpacity = tex.w;
    #endif
    bool _718 = uPixelShader == 2;
    #if (FRAGMENTSHADER == 2)
    matDiffuse = tex.xyz;
    highp float param_1 = ((tex * 4.0) * tex.w).x;
    spec = calcSpec(param_1);
    finalOpacity = tex.w;
    #endif
    bool _736 = uPixelShader == 3;
    #if (FRAGMENTSHADER == 3)
    matDiffuse = tex.xyz;
    emissive = (tex2.xyz * tex.w) * distFade;
    finalOpacity = 1.0;
    #endif
    bool _750 = uPixelShader == 4;
    #if (FRAGMENTSHADER == 4)
    matDiffuse = tex.xyz;
    finalOpacity = 1.0;
    #endif
    bool _757 = uPixelShader == 5;
    #if (FRAGMENTSHADER == 5)
    matDiffuse = tex.xyz;
    emissive = ((tex.xyz * tex.w) * tex2.xyz) * distFade;
    finalOpacity = 1.0;
    #endif
    bool _774 = uPixelShader == 6;
    #if (FRAGMENTSHADER == 6)
    highp vec3 layer1 = tex.xyz;
    highp vec3 layer2 = mix(layer1, tex2.xyz, vec3(tex2.w));
    matDiffuse = mix(layer2, layer1, vec3(vColor2.w));
    finalOpacity = tex.w;
    #endif
    bool _800 = uPixelShader == 7;
    #if (FRAGMENTSHADER == 7)
    highp vec4 colorMix = mix(tex2, tex, vec4(vColor2.w));
    matDiffuse = colorMix.xyz;
    emissive = ((colorMix.xyz * colorMix.w) * tex3.xyz) * distFade;
    finalOpacity = tex.w;
    #endif
    bool _827 = uPixelShader == 8;
    #if (FRAGMENTSHADER == 8)
    highp vec3 layer1_1 = tex.xyz;
    highp vec3 layer2_1 = tex2.xyz;
    matDiffuse = mix(layer2_1, layer1_1, vec3(vColor2.w));
    highp float param_2 = tex2.w * (1.0 - vColor2.w);
    spec = calcSpec(param_2);
    finalOpacity = tex.w;
    #endif
    bool _855 = uPixelShader == 9;
    #if (FRAGMENTSHADER == 9)
    matDiffuse = tex.xyz;
    emissive = (tex2.xyz * tex2.w) * vColor2.w;
    finalOpacity = tex.w;
    #endif
    bool _873 = uPixelShader == 10;
    #if (FRAGMENTSHADER == 10)
    highp float mixFactor = clamp(tex3.w * vColor2.w, 0.0, 1.0);
    matDiffuse = mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(mixFactor)), tex.xyz, vec3(tex.w));
    finalOpacity = tex.w;
    #endif
    bool _905 = uPixelShader == 11;
    #if (FRAGMENTSHADER == 11)
    matDiffuse = tex.xyz;
    emissive = ((tex.xyz * tex.w) * tex2.xyz) + ((tex3.xyz * tex3.w) * vColor2.w);
    finalOpacity = tex.w;
    #endif
    bool _932 = uPixelShader == 12;
    #if (FRAGMENTSHADER == 12)
    matDiffuse = mix(tex2.xyz, tex.xyz, vec3(vColor2.w));
    finalOpacity = 1.0;
    #endif
    bool _945 = uPixelShader == 13;
    #if (FRAGMENTSHADER == 13)
    highp vec3 t1diffuse = tex2.xyz * (1.0 - tex2.w);
    matDiffuse = mix(t1diffuse, tex.xyz, vec3(vColor2.w));
    emissive = (tex2.xyz * tex2.w) * (1.0 - vColor2.w);
    finalOpacity = tex.w;
    #endif
    bool _976 = uPixelShader == 14;
    #if (FRAGMENTSHADER == 14)
    matDiffuse = mix(((tex.xyz * tex2.xyz) * 2.0) + (tex3.xyz * clamp(tex3.w * vColor2.w, 0.0, 1.0)), tex.xyz, vec3(tex.w));
    finalOpacity = 1.0;
    #endif
    bool _1004 = uPixelShader == 15;
    #if (FRAGMENTSHADER == 15)
    highp vec3 layer1_2 = tex.xyz;
    highp vec3 layer2_2 = mix(layer1_2, tex2.xzy, vec3(tex2.w));
    highp vec3 layer3 = mix(layer2_2, layer1_2, vec3(vColor2.w));
    matDiffuse = (layer3 * tex3.xyz) * 2.0;
    finalOpacity = tex.w;
    #endif
    bool _1034 = uPixelShader == 16;
    #if (FRAGMENTSHADER == 16)
    highp vec3 layer1_3 = (tex.xyz * tex2.xyz) * 2.0;
    matDiffuse = mix(tex.xyz, layer1_3, vec3(vColor2.w));
    finalOpacity = tex.w;
    #endif
    bool _1055 = uPixelShader == 17;
    #if (FRAGMENTSHADER == 17)
    highp vec3 layer1_4 = tex.xyz;
    highp vec3 layer2_3 = mix(layer1_4, tex2.xyz, vec3(tex2.w));
    highp vec3 layer3_1 = mix(layer2_3, layer1_4, vec3(tex3.w));
    matDiffuse = (layer3_1 * tex3.xyz) * 2.0;
    finalOpacity = tex.w;
    #endif
    bool _1085 = uPixelShader == 18;
    #if (FRAGMENTSHADER == 18)
    matDiffuse = tex.xyz;
    finalOpacity = tex.w;
    #endif
    bool _1094 = uPixelShader == 19;
    #if (FRAGMENTSHADER == 19)
    highp vec4 tex_6 = texture(uTexture6, vTexCoord2);
    highp vec3 crossDy = cross(dFdy(vPosition.xyz), vNormal);
    highp vec3 crossDx = cross(vNormal, dFdx(vPosition.xyz));
    highp vec2 dTexCoord2Dx = dFdx(vTexCoord2);
    highp vec2 dTexCoord2Dy = dFdy(vTexCoord2);
    highp vec3 sum1 = (crossDx * dTexCoord2Dy.x) + (crossDy * dTexCoord2Dx.x);
    highp vec3 sum2 = (crossDx * dTexCoord2Dy.y) + (crossDy * dTexCoord2Dx.y);
    highp float maxInverseDot = inversesqrt(max(dot(sum1, sum1), dot(sum2, sum2)));
    highp float cosAlpha = dot(normalize(vPosition.xyz), vNormal);
    highp float dot1 = dot(sum1 * maxInverseDot, normalize(vPosition.xyz)) / cosAlpha;
    highp float dot2 = dot(sum2 * maxInverseDot, normalize(vPosition.xyz)) / cosAlpha;
    highp vec4 tex_4 = texture(uTexture4, vTexCoord2 - ((vec2(dot1, dot2) * tex_6.x) * 0.25));
    highp vec4 tex_5 = texture(uTexture5, vTexCoord3 - ((vec2(dot1, dot2) * tex_6.x) * 0.25));
    highp vec4 tex_3 = texture(uTexture3, vTexCoord2);
    highp vec3 mix1 = tex_5.xyz + (tex_4.xyz * tex_4.w);
    highp vec3 mix2 = ((tex_3.xyz - mix1) * tex_6.y) + mix1;
    highp vec3 mix3 = (tex_3.xyz * tex_6.z) + ((tex_5.xyz * tex_5.w) * (1.0 - tex3.z));
    highp vec4 tex_2 = texture(uTexture3, vColorSecond.zy);
    highp vec3 tex_2_mult = tex_2.xyz * tex_2.w;
    bool _1256 = vColor2.w > 0.0;
    highp vec3 emissive_component;
    if (_1256)
    {
        highp vec4 tex_1 = texture(uTexture, vTexCoord);
        matDiffuse = ((tex_1.xyz - mix2) * vColor2.w) + mix2;
        emissive_component = (((tex_1.xyz * tex_1.w) - tex_2_mult) * vColor2.w) + tex_2_mult;
    }
    else
    {
        emissive_component = tex_2_mult;
        matDiffuse = mix2;
    }
    emissive = (mix3 - (mix3 * vColor2.w)) + (emissive_component * tex_2.xyz);
    #endif
    bool _1301 = uPixelShader == 20;
    #if (FRAGMENTSHADER == 20)
    highp vec3 param_3 = vPosition.xyz;
    highp vec3 param_4 = vNormal;
    highp vec4 tex_1_1 = texture(uTexture, posToTexCoord(param_3, param_4));
    highp vec4 tex_2_1 = texture(uTexture2, vTexCoord);
    highp vec4 tex_3_1 = texture(uTexture3, vTexCoord2);
    highp vec4 tex_4_1 = texture(uTexture4, vTexCoord3);
    highp vec4 tex_5_1 = texture(uTexture5, vTexCoord4);
    highp vec4 tex_6_1 = texture(uTexture6, vTexCoord);
    highp vec4 tex_7 = texture(uTexture7, vTexCoord2);
    highp vec4 tex_8 = texture(uTexture8, vTexCoord3);
    highp vec4 tex_9 = texture(uTexture9, vTexCoord4);
    highp float secondColorSum = dot(vColorSecond.zyx, vec3(1.0));
    highp vec4 alphaVec = max(vec4(tex_6_1.w, tex_7.w, tex_8.w, tex_9.w), vec4(0.0040000001899898052215576171875)) * vec4(vColorSecond.zyx, 1.0 - clamp(secondColorSum, 0.0, 1.0));
    highp float maxAlpha = max(alphaVec.x, max(alphaVec.y, max(alphaVec.x, alphaVec.w)));
    highp vec4 alphaVec2 = vec4(1.0) - clamp(vec4(maxAlpha) - alphaVec, vec4(0.0), vec4(1.0));
    alphaVec2 *= alphaVec;
    highp vec4 alphaVec2Normalized = alphaVec2 * (1.0 / dot(alphaVec2, vec4(1.0)));
    highp vec4 texMixed = (((tex_2_1 * alphaVec2Normalized.x) + (tex_3_1 * alphaVec2Normalized.y)) + (tex_4_1 * alphaVec2Normalized.z)) + (tex_5_1 * alphaVec2Normalized.w);
    emissive = (tex_1_1.xyz * texMixed.w) * texMixed.xyz;
    highp vec3 diffuseColor = vec3(0.0);
    matDiffuse = ((diffuseColor - texMixed.xyz) * vColorSecond.w) + texMixed.xyz;
    #endif
    highp vec3 param_5 = matDiffuse;
    highp vec3 param_6 = vNormal;
    bool param_7 = true;
    highp float param_8 = vColor.w;
    SceneWideParams param_9;
    param_9.uLookAtMat = _537.scene.uLookAtMat;
    param_9.uPMatrix = _537.scene.uPMatrix;
    param_9.uViewUp = _537.scene.uViewUp;
    param_9.uInteriorSunDir = _537.scene.uInteriorSunDir;
    param_9.extLight.uExteriorAmbientColor = _537.scene.extLight.uExteriorAmbientColor;
    param_9.extLight.uExteriorHorizontAmbientColor = _537.scene.extLight.uExteriorHorizontAmbientColor;
    param_9.extLight.uExteriorGroundAmbientColor = _537.scene.extLight.uExteriorGroundAmbientColor;
    param_9.extLight.uExteriorDirectColor = _537.scene.extLight.uExteriorDirectColor;
    param_9.extLight.uExteriorDirectColorDir = _537.scene.extLight.uExteriorDirectColorDir;
    param_9.extLight.adtSpecMult = _537.scene.extLight.adtSpecMult;
    InteriorLightParam param_10;
    param_10.uInteriorAmbientColorAndApplyInteriorLight = _525.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_10.uInteriorDirectColorAndApplyExteriorLight = _525.intLight.uInteriorDirectColorAndApplyExteriorLight;
    highp vec3 param_11 = vec3(0.0);
    finalColor = vec4(calcLight(param_5, param_6, param_7, param_8, param_9, param_10, param_11, vColor.xyz, spec, emissive), finalOpacity);
    PSFog arg;
    arg.densityParams = _537.fogData.densityParams;
    arg.heightPlane = _537.fogData.heightPlane;
    arg.color_and_heightRate = _537.fogData.color_and_heightRate;
    arg.heightDensity_and_endColor = _537.fogData.heightDensity_and_endColor;
    arg.sunAngle_and_sunColor = _537.fogData.sunAngle_and_sunColor;
    arg.heightColor_and_endFogDistance = _537.fogData.heightColor_and_endFogDistance;
    arg.sunPercentage = _537.fogData.sunPercentage;
    highp vec4 param_12 = finalColor;
    highp vec3 param_13 = vPosition.xyz;
    highp vec3 param_14 = _537.scene.extLight.uExteriorDirectColorDir.xyz;
    int param_15 = _657.UseLitColor_EnableAlpha_PixelShader_BlendMode.w;
    finalColor = makeFog(arg, param_12, param_13, param_14, param_15);
    outputColor = finalColor;
}


#version 300 es

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
    vec4 adtSpecMult;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct PSFog
{
    vec4 densityParams;
    vec4 heightPlane;
    vec4 color_and_heightRate;
    vec4 heightDensity_and_endColor;
    vec4 sunAngle_and_sunColor;
    vec4 heightColor_and_endFogDistance;
    vec4 sunPercentage;
};

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _93;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
    PSFog fogData;
} _111;

layout(std140) uniform meshWideBlockVS
{
    ivec4 VertexShader_UseLitColor;
} _178;

layout(location = 0) in vec3 aPosition;
out vec4 vPosition;
out vec3 vNormal;
layout(location = 1) in vec3 aNormal;
out vec4 vColor;
layout(location = 6) in vec4 aColor;
out vec4 vColor2;
layout(location = 7) in vec4 aColor2;
out vec4 vColorSecond;
layout(location = 8) in vec4 aColorSecond;
out vec2 vTexCoord4;
layout(location = 5) in vec2 aTexCoord4;
out vec2 vTexCoord;
layout(location = 2) in vec2 aTexCoord;
out vec2 vTexCoord2;
layout(location = 3) in vec2 aTexCoord2;
out vec2 vTexCoord3;
layout(location = 4) in vec2 aTexCoord3;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

void main()
{
    vec4 worldPoint = _93.uPlacementMat * vec4(aPosition, 1.0);
    vec4 cameraPoint = _111.scene.uLookAtMat * worldPoint;
    mat4 viewModelMat = _111.scene.uLookAtMat * _93.uPlacementMat;
    mat4 param = _111.scene.uLookAtMat;
    mat4 param_1 = _93.uPlacementMat;
    mat3 viewModelMatTransposed = blizzTranspose(param) * blizzTranspose(param_1);
    gl_Position = _111.scene.uPMatrix * cameraPoint;
    vPosition = vec4(cameraPoint.xyz, 0.0);
    vNormal = normalize(viewModelMatTransposed * aNormal);
    vColor = aColor.zyxw;
    vColor2 = aColor2;
    vColorSecond = aColorSecond;
    vTexCoord4 = aTexCoord4;
    int uVertexShader = _178.VertexShader_UseLitColor.x;
    #if (VERTEXSHADER == (-1))
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 0)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 1)
    vTexCoord = aTexCoord;
    vTexCoord2 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 2)
    vTexCoord = aTexCoord;
    vec3 param_2 = vPosition.xyz;
    vec3 param_3 = vNormal;
    vTexCoord2 = posToTexCoord(param_2, param_3);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 3)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 4)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 5)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    #endif
    #if (VERTEXSHADER == 6)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 7)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 8)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
}


